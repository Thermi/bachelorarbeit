% This file is part of Bachelorarbeit

% Bachelorarbeit is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License version 3 as published by
% the Free Software Foundation.

% Bachelorarbeit is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.

% You should have received a copy of the GNU General Public License
% along with Foobar. If not, see <http://www.gnu.org/licenses/>.

\section{Vorgehensweise}

Zuerst wurden alle nötigen Änderungen ausfindig gemacht. Dies beinhaltete
die Migrierung von Code von UNIX/Linux-spezifischem IO-Multiplexing
mittels poll() zu anderen Verfahren.

Des weiteren mussten fehlende Features gefunden werden. Einen Hinweis
darauf ließ sich bereits auf den Wiki-Seiten über die Plugins für Windows finden.
Dieser ergab, dass die Verwaltung von virtuellen IPs unter Windows momentan
nicht unterstützt wurde.

Weitere Punkte wurden nach dem ersten Kompilierungsversuch, sowie der Beobachtung
des Verhaltens während dem Tunnelaufbau herausgefunden.

Die Unterstützung für virtuelle IP-Adressen wurden aus dem Zweig ''windows-vip''
vom strongSwan Git-Repository bezogen und angepasst. Der Großteil des Quellcodes
stammt also von Martin Brunner, der diesen Code geschrieben hat. Der Code musste
noch um die Beachtung eines Konfigurationswertes ergänzt werden.

Die Installation der Routen in kernel-libipsec wurde angepasst, sodass es
mit dem TAP-Treiber funktioniert.

\begin{figure}[!ht]
\includegraphics[width=\textwidth]{Diagram.eps}
\caption{Datenflussdiagramm}
\label{fig:Datenflussdiagramm}
\end{figure}

\subsection{Portierung von libipsec auf Windows}
Die Portierung von libipsec auf Windows, sodass sie dort lauffähig ist, ist das Ziel
der Bachelorarbeit. Die zu portierenden Teile des Programmcodes betreffen nur
die Codesegmente, die Plattformspezifische \acp{API} oder \acp{ABI} verwenden,
also primär alles um Dateiein- und Ausgabe, sowie das verwalten von TUN-Geräten.
Unter Unix und Linux werden hier \acp{FD} verwendet. Unter Windows werden stattdessen
Handles genutzt, welche einen anderen Dateityp darstellen. Des weiteren unterscheidet
sich die Methode zum Multiplexen von Lese-Aufrufen auf einer Liste von Handles oder \acp{FD} stark.
Unter Unix und Linux wird hierfür poll() genutzt, unter Windows geschieht das jedoch
Event-basiert mit WaitForMultipleObjects().
Explizite Beispiele hierfür sind im Abschnitt über die Portierung von libipsec sichtbar.
Bei der Portierung wurde für das verwalten von Speicherabschnitten 
primär alloca() genutzt, statt malloc() und seine Unterarten. Der Unterschied hierbei ist die
Speicherdauer. Mit alloca() allokierter Speicher ist nur bis zum Verlassen der Funktion gültig
und wird automatisch freigegeben. Mit malloc() allokierter Speicher muss manuell freigegeben werden.
alloca() ist ein Feature, welches nicht standardisiert ist.
Daher lässt sich strongSwan nicht mit allen C-Bibliotheken übersetzen.
Auf der Wiki-Seite über den Windows-Port wird erwähnt, dass nur die Kompilierung
mittels MinGW-W64 unterstützt wird.


\subsection{Bestehende Implementierung}
Die bestehende Implementierung umfasst die eigentliche Bibliothek, eine Implementierung
eines Kernel-Interface zwischen libipsec und ''charon'', sowie Code in libstrongswan
um TUN-Geräte zu öffnen. Martin Willi hat 2014 bereits die gesamte Portierungsarbeit
für version 5.2.0 von strongSwan gemacht. Der Port unterstützt Windows 7 / server 2008 R2
und neuer.

\subsection{Unterstützte Kryptographie}
Die unterstützte Kryptographie ist notwendigerweise von den deklarierten Identifikatoren
für IKE beschränkt. strongSwan unterstützt mehr Verschlüsselungsalgorithmen als
in den \acp{RFC} deklariert wurde. Aus diesem Grund nutzt strongSwan Identifikatoren
teilweise aus dem privaten Bereich, wenn die Identifikatoren für den eingesetzten Algorithmus
nicht standardisiert sind.

strongSwan unterstützt eine große Anzahl von Algorithmen im Vergleich zu anderen Implementierungen,
wie in den Tabellen in \autoref{sec:appendix} dagelegt wird. Wenn libipsec genutzt wird,
so können alle Algorithmen, die im Userspace implementiert sind, für die Absicherung
von Verkehr genutzt werden.

\subsection{Portierung}
\subsubsection{libipsec}
libipsec implementiert die Verarbeitung von Paketen, das Erzwingen der \acp{SP},
das Verwalten der \acp{SP}, \acp{SA}, Routen und der TUN-Geräte.
Die hierbei relevanten Dateien sind unter /src/libipsec/ zu finden.

Standardmäßig installiert strongSwan die IP-Adressen die per Config-Mode
oder \ac{CP} empfangen wird auf dem ausgehenden Interface (Linux, Kernelspace processing),
was für die Kommunikation mit dem Peer genutzt wird,
oder auf dem Loopback-Adapter (Windows).
Um die IP-Adresse für TUN-Geräte korrekt zu setzen, nutzt libipsec den Parameter
''charon.install\_virtual\_ip\_on'' von strongswan.conf, der während der Initialisierung
des Plugins gesetzt wird.
% route installation
% queues
% processing
% event driven
% job
\paragraph{header}
Die Bibliotheken und Plugins um libipsec nutzen diverse Datenstrukturen und Konstanten,
die in C-Header-Dateien von Linux definiert sind. Diese sind unter Windows nicht verfügbar.
Aus diesem Grund wurde eine Kopie der relevanten Definitionen in den Quellcode kopiert
und fehlende Teile ergänz.
Spezifisch wurde aus dem Quellcode von GLIBC die Definition eines \ac{IP}v4-Headers
und eines \ac{IP}v6-Headers kopiert und die fehlenden Protokollkonstanten per Hand ergänzt.

Diese wurden in ''src/libipsec/win32.h'' abgelegt und in ''src/libpsec/ip\_packet.h'' und ''src/libipsec/ip\_packet.c''
inkludiert. Dies ist in diesem Fall nicht kritisch, da libipsec unter der GPLv2-Lizenz und
die Header unter der GPLv2 und der BSD-Lizenz stehen. Als Name für das Ifdef-Guard
wurde ''WINDOWS\_32\_PROTOCOL\_HEADERS'' gewählt.

\begin{lstlisting}[caption=Header für libipsec]
/* Copyright (C) 1991-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.
*/

/*
 * Copyright (c) 1982, 1986, 1993
 *      The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *      @(#)ip.h        8.1 (Berkeley) 6/10/93
 */

/*
 * Details about licensing:
 * The definition of the IP header is from the headers of GLIBC, that come with Arch Linux
 * It is subject to the license headers of GLIBC and Berkeley
 * The IP protocol identifier constants are manually determined from /etc/protocols
 * and hand written out.  They are subject to the GPLv2.
 */

#ifndef WINDOWS_32_PROTOCOL_HEADERS
#define WINDOWS_32_PROTOCOL_HEADERS

/*
 * Structure of an internet header, naked of options.
 */
struct ip
  {
#if __BYTE_ORDER == __LITTLE_ENDIAN
    unsigned int ip_hl:4;               /* header length */
    unsigned int ip_v:4;                /* version */
#endif
    uint8_t ip_tos;                    /* type of service */
    u_short ip_len;                     /* total length */
    u_short ip_id;                      /* identification */
    u_short ip_off;                     /* fragment offset field */
#define IP_RF 0x8000                    /* reserved fragment flag */
#define IP_DF 0x4000                    /* dont fragment flag */
#define IP_MF 0x2000                    /* more fragments flag */
#define IP_OFFMASK 0x1fff               /* mask for fragmenting bits */
    uint8_t ip_ttl;                    /* time to live */
    uint8_t ip_p;                      /* protocol */
    u_short ip_sum;                     /* checksum */
    struct in_addr ip_src, ip_dst;      /* source and dest address */
  };

struct ip6_hdr
{
  union
    {
      struct ip6_hdrctl
        {
          uint32_t ip6_un1_flow;   /* 4 bits version, 8 bits TC,
                                      20 bits flow-ID */
          uint16_t ip6_un1_plen;   /* payload length */
          uint8_t  ip6_un1_nxt;    /* next header */
          uint8_t  ip6_un1_hlim;   /* hop limit */
        } ip6_un1;
      uint8_t ip6_un2_vfc;       /* 4 bits version, top 4 bits tclass */
    } ip6_ctlun;
  struct in6_addr ip6_src;      /* source address */
  struct in6_addr ip6_dst;      /* destination address */
};


#define ip6_vfc   ip6_ctlun.ip6_un2_vfc
#define ip6_flow  ip6_ctlun.ip6_un1.ip6_un1_flow
#define ip6_plen  ip6_ctlun.ip6_un1.ip6_un1_plen
#define ip6_nxt   ip6_ctlun.ip6_un1.ip6_un1_nxt
#define ip6_hlim  ip6_ctlun.ip6_un1.ip6_un1_hlim
#define ip6_hops  ip6_ctlun.ip6_un1.ip6_un1_hlim


#define IPPROTO_IPIP 4
#define IPPROTO_IPv6 41
#define IPPROTO_NONE 59

#endif /* WINDOWS_32_PROTOCOL_HEADERS */
\end{lstlisting}

\subsubsection{kernel-libipsec}
Die primäre Aufgabe hier war die Installation der Routen in ''kernel\_libipsec\_ipsec.c''
für Windows anzupassen, da hier ein Gateway verwendet wird auf einem TAP-Gerät
statt ein echtes TUN-Gerät, sowie die Anpassung des Codes für die Ein- und Ausgabe 
und einige Methoden in
''kernel\_libipsec\_router.c'', da das Multiplexen der Handles, sowie die Benachrichtigung
von anderen Threads auf Windows anders abläuft als auf Linux und UNIX.

\paragraph{Multiplexing}
Für das Multiplexen der Eingabe stehen unter Windows zwei Verfahren zur Verfügung:
\begin{itemize}
\item WaitForMultipleObjects
\item IOCompletionPorts
\end{itemize}

WaitForMultipleObjects\footcite[][]{_waitformultipleobjects_2016} funktioniert mit einem Array aus Handles. In der Struktur des Handles
ist das event-Attribut auf ein einzgartiges Event gesetzt, welches genutzt wird um
das Handle zu finden, dessen Lesevorgang abgeschlossen oder abgebrochen wurde.
Nach dem Kopieren des Handles in das Array und dem Setzen des Events wird ein asynchroner
Lesevorgang gestartet. Wenn er sofort beendet wurde, wird das entsprechende Event gesetzt.
Dadurch beendet der Aufruf von WaitForMultipleObjects() nach dem Aufruf direkt, falls
ein Lesevorgang schon zuvor erfolgreich war und der Programmcode wird etwas kürzer.
% Mehr Erläuterung benötigt

IOCompletionPorts\footcite[][]{_createiocompletionport_2016} funktionieren, indem man einen IOCompletionPort mit CreateIoCompletionPort()
anlegt und Handles mit ihm asoziiert. Bei der Asoziierung wird ein einzigartiger Schlüssel
übergeben, der bei der Signalisierung wieder zurückgegeben wird um das Handle identifizieren zu können.
Der CompletionPort kann erst nach dem Schließen der asoziierten Handles geschlossen werden.
Mit der Funktion GetQueuedCompletionStatus() kann der ausführende Thread dann auf abgeschlossene
I/O-Operationen warten.
Die Nachteile dieser Methode sind, dass jegliche Operationen auf den Handles eine Benachrichtigung
an GetQueuedCompletionStatus() generieren, obwohl Schreib-Vorgänge nicht von Interesse sind.

Des weiteren ähnelt die Nutzung von WaitForMultipleObjects() deren von poll()
insoweit, dass die Handles/\acp{FD} auch nach der Benutzung mit der Funktion
weiterhin einzeln genutzt werden können.
% Mehr Erläuterung benötigt

Da es relativ einfach ist WaitForMultipleObjects() zu nutzen, wurde diese Methode
für die Implementierung von handle\_plain() genutzt.

Die Zustände der Originalimplementierung sind in ~\autoref{fig:poll_fd}
dargestellt.

\begin{figure}
\centering
\def\svgwidth{\columnwidth}
\includegraphics[width=\textwidth]{poll_fd.eps}
\caption{Zustände in handle\_plain() mittels poll()}
\label{fig:poll_fd}
\end{figure}


Wie aus dem Diagramm hervorgeht, wird im Prinzip nur ein Array mit Strukturen des Typs
''pollfd'' erstellt, dann mit einem Notification-\ac{FD} und den \acp{FD} der TUN-Geräte befüllt
und als gewünschte Events ''POLLIN'' gesetzt. Das heißt, dass der Aufruf von poll() ohne
Fehler beendet wird, wenn Daten auf dem \acp{FD} zur Verfügung stehen.
Danach wird poll() auf die ''pollfd''-Datenstruktur ausgeführt und analysiert,
auf welchen \acp{FD} Daten zur Verfügung stehen. Dieser Code ist relativ kurz im
Vergleich zum Analogon mit WaitFor*Objects() Funktionen unter Windows.
Dies geht aus den vergleichbaren Implementierungsmöglichkeiten, die sich aus den
WaitFor*Objects()-Funktionen ergeben. Dies wird im Diagramm \autoref{fig:WaitForMultipleObjects}
und \autoref{fig:WaitForMultipleObjects2} hervor. Diese Diagramme haben weitaus
mehr Zustände als \autoref{fig:poll_fd}.

Der Unterschied zwischen der Implementierung von \autoref{fig:WaitForMultipleObjects}
und \autoref{fig:WaitForMultipleObjects2} ist, dass \autoref{fig:WaitForMultipleObjects2}
effektiver und schneller ist, da die Puffer nach jedem Lesevorgang beibehalten werden
und IO-Operationen weiterlaufen können.
In \autoref{fig:WaitForMultipleObjects} werden die Puffer und Operationen
immer freigegeben und gestoppt. Das ist unnötig, bringt die Implementierung
jedoch näher an das Verhalten von \autoref{fig:poll_fd}.
Es wurde das Verfahren aus \autoref{fig:WaitForMultipleObjects2} implementiert,
da es schneller und effektiver ist.

In handle\_plain werden zwei verschiedene Arrays benutzt.
\begin{description}
\item[bundle\_array] Ein Array aus Strukturen vom Typ ''handle\_overlapped\_buffer\_t''. 
\item[event\_array] Ein Array aus Events (HANDLE).
\end{description}

Strukturen vom Typ ''handle\_overlapped\_buffer\_t'' beinhalten jeweils ein Objekt
vom Typ HANDLE, ein Objekt vom Typ *OVERLAPPED und ein Objekt vom Typ chunk\_t.
Das Handle gehört zu einem TUN-Handle, das OVERLAPPED-Objekt wird direkt für asynchrones
IO benötigt und das Objekt vom Typ chunk\_t beinhaltet den Pufferspeicher und dessen Länge.

Das ''event\_array'' Array zum Multiplexen mittels WaitForMultiplEvents() genutzt und
beinhaltet die gleichen Events, wie die Strukturen des Typs OVERLAPPED.
Bei der Ausführung von WaitForMultipleObjects() auf das Array wird darauf gewartet, dass
eine vorher gestartete Leseoperation auf einem Handle fertig gestellt wird.
Das signalisiert ein Event im Array und dessen Position im Array verrät welche
Position im bundle\_array einen nun gefüllten Puffer hat. Die Position signalisiert
hierbei nur die niedrigste Position im Array, deren Event signalisiert wurde. Ein
im Array höher gelegenes Event könnte auch signalisiert sein.
Der Puffer kann nun gelesen
werden und an die Queue zu libipsec gehängt werden. Nach dem Lesen wird die OVERLAPPED-Struktur
und das Event zurückgesetzt, sowie der Puffer mit Nullen initialisiert und die Länge zurückgesetzt.
Danach wird ein neuer Lesevorgang auf dem oder den Handles gestartet, deren Leseoperationen
fertig sind.

Der Code in auf Seite \pageref{lst:handle-plain-windows} zeigt die Implementierung von handle\_plain()
auf Windows. Die Funktionen zum Starten von asynchronen Leseoperationen auf Handles
wurden in start\_read() abgekapselt. Das Übersetzen von Fehlercodes in menschenlesbare
Texte wurde in format\_error() abgekapselt. Bei Fehlern beim Lesen startet sich der Job
mit JOB\_REQUEUE\_FAIR neu, sodass der Job als letzter vom Job-Manager in ''charon'' neugestartet wird,
wenn hoffentlich der Fehler nicht erneut auftritt.

\begin{figure}
\centering
\def\svgwidth{\columnwidth}
\includegraphics[width=\textwidth]{WaitForMultipleObjects.eps}
\caption{Zustände in handle\_plain() mittels WaitForMultipleObjects(), Variante 1}
\label{fig:WaitForMultipleObjects}
\end{figure}

\begin{figure}
\centering
\def\svgwidth{\columnwidth}
\includegraphics[width=\textwidth]{WaitForMultipleObjects2.eps}
\caption{Zustände in handle\_plain() mittels WaitForMultipleObjects(), Variante 2}
\label{fig:WaitForMultipleObjects2}
\end{figure}

\paragraph{Routing}
libipsec setzt für die von ihr installierten Routen standardmäßig das ''Gateway''
oder ''Next Hop''Feld nicht. Der Grund dafür ist, dass libipsec bisher nur auf
Betriebssytemen genutzt wurde, die echte Layer-3-Geräte implementieren und
daher keine Kollisionsdomäne über das Gerät erreichbar ist. Daher ergibt es keinen
Sinn das ''next hop''-Feld zu setzen.
Auf Windows ist dies jedoch, wie zuvor erläutert, nicht der Fall, da der TAP-Windows-Treiber
TUN-Geräte als Ethernet-Gerät emuliert.
Der Struct ''route'' is vom Typ ''route\_entry\_t'' und wird in der Funktion
''install\_route'' genutzt, um die zu installierende Route zu bestimmen.
Das Gateway-Feld wird genutzt, um das Next-Hop-Feld der Routen im Routing-Table
zu setzen. 
Der TAP-Windows6-Treiber nutzt für IPv6 einen statische IP addresse im link-local-Bereich
der IPv6-Spezifikation.
Für IPv4 lässt sich die IP-Adresse des Adapters implizit konfigurieren, wie zuvor erklärt.
Das Object, welches mittels ''host\_create\_from\_string'' erstellt wird,
wird von der Funktion auf dem Heap abgelegt. Damit ist es auch nach dem Verlassen
des Funktionsblocks noch valide. Es wird automatisch beim Zerstören des Objekts
''route'' freigegeben.

\begin{lstlisting}[caption=Patch für die Routen-Installation von libipsec]
#ifdef __linux__
#elif defined(WIN32)
        /* Set out special gateway */
        family = route->src_ip->get_family(route->src_ip);
        switch(family)
        {
            case AF_INET:
            {
                /* For IPv4, the nxt hop is 169.254.128.128 (Configured next hop) */
                host_t *gw = host_create_from_string("169.254.128.128", 0);
                route->gateway = gw;
                break;
            }
            case AF_INET6:
            {
                /* For IPv6, the next hop is fe80::8 (TAP-Windows6 magic router gw) */
                host_t *gw = host_create_from_string("fe80::8", 0);
                route->gateway = gw;
                break;
            }
            default:
                DBG2(DBG_ESP, "Unknown Protocol family %d encountered. Not setting a next hop.", family);
                break;
        }
#else
	/* on Linux we cant't install a gateway */
	route->gateway = charon->kernel->get_nexthop(charon->kernel, dst, -1, src);
#endif
\end{lstlisting}

Die Implementierung von handle\_plain() auf Windows unterstütz, wie die Implementierung
auf Linux und UNIX das Multiplexen von IO von mehreren TUN-Adaptern. Der Grund dafür ist,
dass verschiedene TUN-Implementierungen gegebenenfalls verschiedene Adapter für mehrere Tunnel
benötigen. Mit dem TAP-Windows-Treiber ist dies zwar nicht der Fall, es wurde der Vollständigkeit
halber jedoch mitemplementiert.

% libipsec router
% handle_plain
% notification event
% job
% handle_plain
% handle_esp
% up
% destroy
%kernel_libipsec_ipsec route installation
\subsubsection{libstrongswan}
Hier galt es das Öffnen, Konfigurieren und Schließen von TUN-Geräten
mit dem TAP-Windows-Treiber zu implementieren.

% Bezugsquelle für den Treiber
Der Treiber ist kompiliert auf der OpenVPN-Seite
verfügbar\footnote{\url{https://openvpn.net/index.php/open-source/downloads.html}}
und der Quellcode auf Github\footnote{\url{https://github.com/OpenVPN}}.
Die Basis für die Implementierung war hier der existierende Programmcode in
OpenVPN, spezifisch in  der Datei ''src/openvpn/tun.c.''.

\paragraph{TAP-Geräte erstellen}
Das Erstellen von TAP-Geräten ist im Moment nicht unterstützt. Der Grund dafür ist,
dass die Funktionalität von ''devcon.exe'' dafür nachgebaut werden müsste, was
sehr zeitaufwendig ist. Des weiteren ist der Quellcode von ''devcon.exe'' nicht offen,
weshalb es Lizensierungsprobleme damit geben könnte.

\paragraph{TAP-Geräte suchen}
Um das TAP-Gerät zu nutzen versucht der Code zuerst nach Netzwerkgeräten mit der ID ''tap0901'' zu suchen,
welche die ID für TAP-Geräte ist. Dies wird über die Registry getan. Hierbei wird
im Pfad \begin{lstlisting}[numbers=none]
HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318\}
\end{lstlisting}
nach Verbindungen gesucht, deren ''ComponentId''-Feld den Wert ''tap0901'' besitzen.
Bei passenden Schlüsseln wird der Wert ''NetCfgInstanceId'' an eine linked list
angehängt. Die NetCfgInstanceId identifiziert jeden Netzwerkadapter unter Windows
mittels einer einzigartigen ID.
Vor dem Beenden der Funktion wird die linked list zurückgegeben.
Diese Funktionalität ist in der Funktion get\_tap\_reg() in der Datei
''src/libstrongswan/networking/tun\_device.c'' gekapselt.

Der Code hierfür ist im Appendix unter \autoref{lst:get_tap_req} aufzufinden.

\paragraph{TAP-Geräte öffnen}
TAP-Geräte sind im Usermode über den Globalen Addressraum für Userspaceadapter
unter ''\textbackslash{}\textbackslash{}.\textbackslash{}\textbackslash{}Global\textbackslash{}\textbackslash{}\$NetCfgInstanceId.tap'' erreichbar.
''\$NetCfgInstanceId'' steht hierbei für die vorher mit ''get\_tap\_req()'' gefundenen
''NetCfgInstanceId''-Werte der gefundenen TAP-Adapter.

\begin{lstlisting}[numbers=none]
CreateFile(device_path, GENERIC_READ \| GENERIC_WRITE, 0,
                    0, OPEN_EXISTING, FILE_ATTRIBUTE_SYSTEM | FILE_FLAG_OVERLAPPED, 0);
\end{lstlisting}

Das Handle kann nun genutzt werden um Pakete vom TAP-Gerät zu lesen und zu schreiben.
Mittels DeviceIoControl kann die Konfiguration des Geräts geändert werden,
wie die IP des virtuellen Routers, den Status des Geräts sowie der Modus des Geräts.

Für die Portierung wurden die \acp{FD} für Handles ausgetauscht und für das Benachrichtigen
über Änderungen in der Liste der TUN-Geräte wurde ein Event verwendet.

Da Eventbasiertes IO-Multiplexing genutzt wird, werden verschiedene Events zum Lesen
und Schreiben verwendet.
Die Namen der Events werden als Attribut des Objekts in ''tun\_device\_t->read\_event\_name''
''tun\_device\_t->write\_event\_name'' gespeichert. Sie können mittels ''tun\_device\_t->get\_read\_event\_name()'
und ''tun\_device\_t->get\_read\_event\_name()'' gelesen werden.

\paragraph{Ändern der MTU eines TAP-Geräts}
Das Ändern der \ac{MTU} ist im Moment nicht unterstützt. Der Treiber ermöglicht es,
die \ac{MTU} über die Windows-Registry zu ändern. Dort wird der Schlüssel ''MTU''
dafür genutzt. Er steht standardmäßig auf ''1500'', welches die Standard-\ac{MTU}
von Ethernet ist.
\paragraph{Konfiguration eines TAP-Geräts}
Die Konfiguration eines TAP-Geräts geschieht mit den IOCTL-Werten aus ~/autoref{fig:tap-ioctls}.

Bei der Konfiguration eines TAP-Geräts für die Benutzung mit strongSwan müssen die folgenden
Schritte ausgeführt werden:
\begin{itemize}
\item Das Gerät in den TUN-Modus setzen. Dabei werden als Parameter
die lokale IP (169.254.128.127), die IP des virtuellen Routers (169.254.128.128)
und die Netzmaske des entfernten Netzwerks (255.255.255.255) gesetzt. 
(TAP\_WIN\_IOCTL\_CONFIG\_TUN)
\item Deaktivierung der Überprüfung des ''Sender protocol address''-Feldes.\\
(TAP\_WIN\_IOCTL\_CONFIG\_SET\_SRC\_CHECK)
\item Adapter in den ''up''-Zustand setzen (einschalten). 
Nach dem Setzen des Zustands muss kurz gewartet werden um sicher zu gehen, dass das Gerät auch aktiv ist.\\
(TAP\_WIN\_IOCTL\_SET\_MEDIA\_STATUS)
\end{itemize}

Folgend ist der Code für das Konfigurieren eines TAP-Geräts:
\begin{lstlisting}[caption=Konfiguration eines TAP-Geräts]
/**
 * Initialize the tun device
 */
static bool init_tun(private_tun_device_t *this, const char *name_tmpl)
[...]
#elif defined(WIN32)
        /* WIN32 TAP driver stuff*/
        /* Check if there is an unused tun device following the IPsec name scheme*/
        enumerator_t *enumerator;
        char *guid;
        BOOL success = FALSE;
        linked_list_t *possible_devices = get_tap_reg();
        memset(this->if_name, 0, sizeof(this->if_name));

        this->read_event_name = malloc(WIN32_TUN_EVENT_LENGTH);
        this->write_event_name = malloc(WIN32_TUN_EVENT_LENGTH);
        /* Iterate over list */
        enumerator = possible_devices->create_enumerator(possible_devices);
        /* Try to open that device */
        while(enumerator->enumerate(enumerator, &guid))
        {
            if (!success){
                /* Set mode */
                char device_path[256];
                /* Translate dev name to guid */
                /* TODO: Fix. device_guid should be */
                snprintf (device_path, sizeof(device_path), "%s%s%s", USERMODEDEVICEDIR, guid, TAP_WIN_SUFFIX);

                this->tunhandle = CreateFile(device_path, GENERIC_READ | GENERIC_WRITE, 0,
                    0, OPEN_EXISTING, FILE_ATTRIBUTE_SYSTEM | FILE_FLAG_OVERLAPPED, 0);
                if (this->tunhandle == INVALID_HANDLE_VALUE)
                {
                    DBG1(DBG_LIB, "could not create TUN device %s", device_path);
                }
                else
                {
                    memcpy(this->if_name, guid, strlen(guid));
                    success = TRUE;
                }
            }
            else
            {
                break;
            }
            /* device has been examined or used, free it */
            free(guid);
        }

        /* possible_devices has been freed while going over the enumerator.
         * Therefore it is not necessary to free the elements in the list now.
         */
        enumerator->destroy(enumerator);
        possible_devices->destroy(possible_devices);
        if (!success)
        {
            return FALSE;
        }
        /* set correct mode */
        /* We set a fake gateway of 169.254.254.128 that we route packets over
         The TAP driver strips the Ethernet header and trailer of the Ethernet frames
         before sending them back to the application that listens on the handle */
	struct in_addr ep[3];
        ULONG status = TRUE;
        DWORD len;
        /* Local address (just fake one): 169.254.128.127 */
	ep[0].S_un.S_un_b.s_b1 = 169;
        ep[0].S_un.S_un_b.s_b2 = 254;
        ep[0].S_un.S_un_b.s_b3 = 128;
        ep[0].S_un.S_un_b.s_b4 = 127;
        /*
         * Remote network. The tap driver validates it by masking it with the remote_netmask
         * and then comparing hte result against the remote network (this value here).
         * If it does not match, an error is logged and initialization fails.
         * (local & remote_netmask ? local)
         * The driver does proxy arp for this network and the local address.
         */
        /* We need to integrate support for IPv6, too. */
        /* Just fake a link local address for now (169.254.128.128) */
	ep[1].S_un.S_un_b.s_b1 = 169;
        ep[1].S_un.S_un_b.s_b2 = 254;
        ep[1].S_un.S_un_b.s_b3 = 128;
        ep[1].S_un.S_un_b.s_b4 = 128;
        /* Remote netmask (255.255.255.255) */
	ep[2].S_un.S_un_b.s_b1 = 255;
        ep[2].S_un.S_un_b.s_b2 = 255;
        ep[2].S_un.S_un_b.s_b3 = 255;
        ep[2].S_un.S_un_b.s_b4 = 255;

        if(!DeviceIoControl (this->tunhandle, TAP_WIN_IOCTL_CONFIG_TUN,
		    ep, sizeof (ep),
		    ep, sizeof (ep), &len, NULL))
        {
            DBG1 (DBG_LIB, "WARNING: The TAP-Windows driver rejected a TAP_WIN_IOCTL_CONFIG_TUN DeviceIoControl call.");
        }

        ULONG disable_src_check = FALSE;
        if(!DeviceIoControl(this->tunhandle, TAP_WIN_IOCTL_CONFIG_SET_SRC_CHECK,
                    &disable_src_check, sizeof(disable_src_check),
                    &disable_src_check, sizeof(disable_src_check), &len, NULL))
        {
            DBG1 (DBG_LIB, "WARNING: The TAP-Windows driver rejected a TAP_WIN_IOCTL_CONFIG_SET_SRC_CHECK DeviceIoControl call.");
        }
        ULONG driverVersion[3] = {0 , 0, 0};
        if(!DeviceIoControl(this->tunhandle, TAP_WIN_IOCTL_GET_VERSION,
                    &driverVersion, sizeof(driverVersion),
                    &driverVersion, sizeof(driverVersion), &len, NULL))
        {
            DBG1(DBG_LIB, "WARNING: The TAP-Windows driver rejected a TAP_WIN_IOCTL_GET_VERSION DeviceIoControl call.");
        }
        else
        {
            DBG1(DBG_LIB, "TAP-Windows driver version %d.%d available.", driverVersion[0], driverVersion[1]);
        }
        /* Set device to up */

        if (!DeviceIoControl (this->tunhandle, TAP_WIN_IOCTL_SET_MEDIA_STATUS,
  			  &status, sizeof (status),
                            &status, sizeof (status), &len, NULL))
        {
            DBG1 (DBG_LIB, "WARNING: The TAP-Windows driver rejected a TAP_WIN_IOCTL_SET_MEDIA_STATUS DeviceIoControl call.");
        }

            /* Give the adapter 2 seconds to come up */
        /* Create event with special template */
        snprintf(this->read_event_name, WIN32_TUN_EVENT_LENGTH, WIN32_TUN_READ_EVENT_TEMPLATE, this->if_name);
        snprintf(this->write_event_name, WIN32_TUN_EVENT_LENGTH, WIN32_TUN_WRITE_EVENT_TEMPLATE, this->if_name);
        sleep(2);
        return TRUE;
        [...]
}
\end{lstlisting}

\paragraph{Lesen und Schreiben vom Adapter}
Beim Öffnen des Adapters wurde ein Handle erstellt.
Durch asynchrone Lese- und Schreiboperationen mittels ReadFile() und WriteFile()
unter Benutzung von ''OVERLAPPED''-Strukturen und Events lassen sich Pakete
lesen und schreiben.

\paragraph{tun\_device\_t}
Folgend der Code für das Erstellen eines Objects vom Typ ''tun\_device\_t''.

\begin{lstlisting}[caption=Code für das Erstellen von tun\_device\_t]
/*
 * Described in header
 */
tun_device_t *tun_device_create(const char *name_tmpl)
{
	private_tun_device_t *this;

	INIT(this,
		.public = {
			.read_packet = _read_packet,
			.write_packet = _write_packet,
			.get_mtu = _get_mtu,
			.set_mtu = _set_mtu,
			.get_name = _get_name,
                        /* For WIN32, that's a handle. */
#ifdef WIN32
                        .get_handle = _get_handle,
                        .get_write_event_name = _get_write_event_name,
                        .get_read_event_name = _get_read_event_name,
#else
			.get_fd = _get_fd,
#endif /* WIN32 */
			.set_address = _set_address,
			.get_address = _get_address,
			.up = _up,
			.destroy = _destroy,
		},
#ifdef WIN32
                .tunhandle = NULL,
#else
		.tunfd = -1,
		.sock = -1,
#endif /* WIN32 */
	);

	if (!init_tun(this, name_tmpl))
	{
		free(this);
		return NULL;
	}
	DBG1(DBG_LIB, "created TUN device: %s", this->if_name);

#ifdef WIN32
#else
	this->sock = socket(AF_INET, SOCK_DGRAM, 0);
	if (this->sock < 0)
	{
		DBG1(DBG_LIB, "failed to open socket to configure TUN device");
		destroy(this);
		return NULL;
	}
#endif /* WIN32 */
	return &this->public;
}

#endif /* TUN devices supported */
\end{lstlisting}

\begin{lstlisting}[caption=Relevanter code für tun\_device\_t->destroy()]
METHOD(tun_device_t, destroy, void,
	private_tun_device_t *this)
{
#ifdef WIN32
        /* close file handle, destroy interface */
        CloseHandle(this->tunhandle);
        free(this->read_event_name);
        free(this->write_event_name);
#else
        [...]
#endif
    	DESTROY_IF(this->address);
    	free(this);
}
\end{lstlisting}
% callbacks
% synchronous
% WaitForMultipleObjects
% komplexe Änderungen des Verhaltens von kernel-libipsec

\subsubsection{kernel-iph}
kernel-iph ist ein Plugin für ''charon'', das das Kernel-Interface
für die Verwaltung von IP-Adressen und Routen implementiert.

Ursprünglich war das Verwalten von IP-Adressen im Master-Zweig nicht implementiert.
Eine vollständige Implementierung existiert im Zweig ''win-vip'', die in den Zweig 'windows-libipsec'
gemerged wurde, um eine vollständige Implementierung dort zu erhalten.

Nachgerüstet werden musste Code zum Beachten des ''charon.install\_virtual\_ip\_on'' Parameters
der in der Datei ''strongswan.conf'' definiert werden kann und den libipsec nutzt um
die Installation der empfangenen IP-Adresse(n) auf den richtigen Adapter zu erzwingen.
Der Code kopiert den Adapternamen während der Initialisierung des Plugins, daher
ändert ein Ändern des Parameters während der Laufzeit nicht die Schnittstelle,
auf die die IP-Adresse installiert werden würde.

Die bekannten IP-Adressen werden in kernel-iph in einer Datenstruktur gespeichert,
um sie schnell nachschlagen zu können und Berechnungen zu tätigen. Die Struktur
wird einerseits durch manuelles Einfügen und Entfernen von selbstinstallierten Adressen
bewerkstelligt, als auch durch Events, die die Anwendung über ein Handle
vom Kernel empfängt.

\begin{lstlisting}[caption=Ergänzung zu private\_kernel\_iph\_net\_t]
/**
 * Private data of kernel_iph_net implementation.
 */
struct private_kernel_iph_net_t {
        [...]
        /**
         * Whether to install virtual IPs
         */
        bool install_virtual_ip;

        /**
         * Where to install virtual IPs
         */

        char *install_virtual_ip_on;
};
\end{lstlisting}

\begin{lstlisting}[caption=Code für add\_ip]
METHOD(kernel_net_t, add_ip, status_t,
	private_kernel_iph_net_t *this, host_t *vip, int prefix, char *name)
{
	if (!this->install_virtual_ip)
	{	/* disabled by config */
		return SUCCESS;
	}
	MIB_UNICASTIPADDRESS_ROW row;
	u_long status;
        iface_t *iface = NULL, *entry = NULL;

        /* Print out all known interfaces */
        enumerator_t *enumerator = this->ifaces->create_enumerator(this->ifaces);
        while(enumerator->enumerate(enumerator, &entry))
        {
            DBG1(DBG_KNL, "interface %s\n index: %d\n description %s\n type %d", entry->ifname, entry->ifindex, entry->ifdesc, entry->iftype);
        }
        enumerator->destroy(enumerator);
	/* name of the MS Loopback adapter */
        if (!this->install_virtual_ip_on || this->ifaces->find_first(this->ifaces, (void*)iface_by_name,
						(void**)&iface, this->install_virtual_ip_on) != SUCCESS)
        {
            name = "{DB2C49B1-7C90-4253-9E61-8C6A881194ED}";
        }
        else
        {
            name = this->install_virtual_ip_on;
        }
	host2unicast(vip, prefix, &row);

	row.InterfaceIndex = add_addr(this, name, vip, TRUE);
	if (!row.InterfaceIndex)
	{
		DBG1(DBG_KNL, "interface '%s' not found", name);
		return NOT_FOUND;
	}

	status = CreateUnicastIpAddressEntry(&row);
	if (status != NO_ERROR)
	{
		DBG1(DBG_KNL, "creating IPH address entry failed: %lu", status);
		remove_addr(this, vip);
		return FAILED;
	}
	return SUCCESS;
}
\end{lstlisting}

\begin{lstlisting}[caption=Code für del\_ip]
METHOD(kernel_net_t, del_ip, status_t,
	private_kernel_iph_net_t *this, host_t *vip, int prefix, bool wait)
{
        if (!this->install_virtual_ip)
	{	/* disabled by config */
		return SUCCESS;
	}

	MIB_UNICASTIPADDRESS_ROW row;
	u_long status;

	host2unicast(vip, prefix, &row);

	row.InterfaceIndex = remove_addr(this, vip);
	if (!row.InterfaceIndex)
	{
		DBG1(DBG_KNL, "virtual IP %H not found", vip);
		return NOT_FOUND;
	}

	status = DeleteUnicastIpAddressEntry(&row);
	if (status != NO_ERROR)
	{
		DBG1(DBG_KNL, "deleting IPH address entry failed: %lu", status);
		return FAILED;
	}

	return SUCCESS;
}
\end{lstlisting}

\begin{lstlisting}[caption=Ergänzung zu kernel\_iph\_net\_create()]
*
 * Described in header.
 */
kernel_iph_net_t *kernel_iph_net_create()
{
        [...}
		.install_virtual_ip = lib->settings->get_bool(lib->settings,
						"%s.install_virtual_ip", TRUE, lib->ns),
		.install_virtual_ip_on = lib->settings->get_str(lib->settings,
						"%s.install_virtual_ip_on", NULL, lib->ns),
	   [...]
}
\end{lstlisting}

Für das Implementieren des Codes für den TAP-Treiber werden Magic Numbers benötigt,
welche sich im Quellcode von OpenVPN finden lassen. Diese wurden übernommen
und in einer Header-Datei angelegt.
Teilweise wurden auch die Konstanten für die Erzeugung der Namen der Events für
das IO-Multiplexen dort abgelegt. Die Datei ist im Appendix unter \autoref{lst:libstrongswan-win32.h}
zu finden.

Der gesamte gepatchte Quellcode von strongSwan ist auf der CD unter strongSwan/ zu finden
Der Patch ansich ist unter patches/strongSwan/tap-handling.patch zu finden.

\subsection{TAP-Treiber}
% openvpn
% kompatibilität
% Treiber-patches upstream
Im Zuge der \ac{BA} wurde ein Patch für den TAP-Windows-Treiber entwicklelt, um die
Prüfung der Quell-IP der ARP-Requests zu deaktivieren. Das ist erforderlich, um mit der
virtuellen IP des Clients mit dem entfernten IP-Netzwerk kommunizieren zu können.


\subsubsection{Bauen und Installieren des Treibers}
Um den Treiber zu bauen, wird zuallererst der Quellcode benötigt, sowie die
Vorraussetzungen, welche auf der Github-Seite dort aufgelistet sind.
Die aktuellen Minimalvorraussetzungen sind Python 2.7, das Microsoft Windows 7 WDK (Windows Driver Kit)
und ein Windows Code signing certificate.
Das Zertifikat muss nicht valid sein, wenn der Treiber nicht produktiv ausgerollt
werden soll. Der Grund ist, dass unter Windows das Überprüfen der Treibersignatur deaktiviert
werden kann, aber der Treiber muss trotzdem signiert sein. Der Trust-path muss aber nicht
zu einem öffentlichen Trust Anchor (eine CA) führen. Um den Treiber signieren zu können,
wird die gesamte Trust Chain benötigt, sowie der private Schlüssel des Zertifikats.
Um ein Zertifikat mit dem dazugehörigen privaten Schlüssel importieren zu können,
müssen die Dateien in einen PKCS\#12-Container gepackt werden. Dieser kann mit 
OpenSSL erstellt werden, zum Beispiel mit diesem Befehl:
\begin{lstlisting}[caption=OpenSSL PKCS\#12]
openssl pkcs12 -export -in key key.key -in certificate.pem -out pkcs12.p12
\end{lstlisting}
Die mit diesem Befehl erstellte Datei pkcs12.p12 kann dann durch einen Doppelklick auf sie
in den Windows importiert werden.

Der Befehl um den Treiber dann zu bauen kann so aussehen:
\begin{lstlisting}[caption=TAP-Windows bauen]
python buildtap.py -c -b -d --cert="csc" --sign --crosscert="C:\Users\Noel\certs\rootca.pem"
\end{lstlisting}
Die Ausgabe des Befehls listet die Kompilierung, sowie das Signieren der Dateien auf.
% Hier noch Ausgabe der Kompilierung aufführen, sowie welche Teile kritisch sind.
Wie zu sehen ist, muss das Root-CA-Zertifikat als Datei vorhanden sein.
Das Code Signing certificate wird nur mit seinem Common Name angegeben.
Damit das WDK es findet, muss es in ''Eigene Zertifikate'' zu finden sein.
\begin{figure}
\includegraphics[scale=0.33]{/home/thermi/FH-Stuff/UNITS-8/Bachelorarbeit/Bachelorarbeit/Bilder/Eigene_Zertifikate.png}
\caption{Eigene-Zertifikate-Menü}
\label{fig:Eigene-Zertifikate-Menue}
\end{figure}

Mit Windows im Testmodus kann der Treiber geladen werden und TAP-Geräte konnen
mittels tapinstall.exe (Was eigentlich ''devcon.exe'' ist). Die Datei ist im Quellcode des
Treibers nicht mitenthalten. Sie kann jedoch durch die Installation des Treiber-Pakets
von der OpenVPN-Webseite erhalten werden. Nach der Installation des Pakets
ist die Datei unter \textit{C:\textbackslash{}Program Files\textbackslash{}TAP-Windows\textbackslash{}bin\textbackslash{}tapinstall.exe}
zu finden und kann zur Erstellung und zum Löschen von TAP-Geräten genutzt werden.

Der erste Parameter ist offensichtlich ''install'' oder ''remove''. Der Pfad zur .inf-Datei
über den Treiber muss beim Erstellen eines Geräts angegeben werden. Hier im Beispiel
ist es die Datei, die mittels des Python-Skripts erstellt wurde. Bei der Installation
dieses Treibers wird der von mir kompilierte Treiber installiert, welcher sich unter 
''C:\textbackslash{}Users\textbackslash{}Noel\textbackslash{}tap-driver\textbackslash{}dist\textbackslash{}amd64\textbackslash{}OemVista.inf''
befindet.

\begin{lstlisting}[caption=Erstellung eines TAP-Geraets]
"C:\Program Files\TAP-Windows\bin\tapinstall.exe" install "C:\Users\Noel\tap-driver\dist\amd64\OemVista.inf" tap0901
\end{lstlisting}

\begin{lstlisting}[caption=Löschung aller TAP-Geraete]
"C:\Program Files\TAP-Windows\bin\tapinstall.exe" remove tap0901
\end{lstlisting}

\paragraph{ABI}
Die \ac{ABI} des Treibers ist undokumentiert. Im Folgenden ist eine Auflistung
der Funktionen der \ac{ABI}. Sie wurden aus der Datei ''src/device.c'' extrahiert
und aufgeschlüsselt. Für mehr Informationen bezüglich des Verhaltens und der
genauen Eingabeparameter sollte die Datei konsultiert werden.

\begin{table}
\tiny
\begin{tabularx}{\textwidth}{|c|c|c|c|X|X|}\firsthline
IOCtl & Makro & Eingabe & Ausgabe & Zweck & Kommentar \\ \hline
1 & TAP\_WIN\_IOCTL\_GET\_MAC & NULL & char[6] & Gibt die MAC-Adresse des Geräts zurück & \\ \hline
2 & TAP\_WIN\_IOCTL\_GET\_VERSION & NULL & ULONG[3] & Gibt die Version des Treibers zurück & \\ \hline
3 & TAP\_WIN\_IOCTL\_GET\_MTU & NULL & ULONG & Gibt die \ac{MTU} des Geräts zurück & \\ \hline
4 & TAP\_WIN\_IOCTL\_GET\_INFO & NULL & N/A & Gibt Informationen über den Adapter zurück
& Ist laut Code für NDIS6 nicht implementiert \\ \hline 
5 & TAP\_WIN\_IOCTL\_CONFIG\_POINT\_TO\_POINT & IPADDR[2] (2*4 CHAR) & NULL & Setzt das Gerät in den Point-To-Point-Modus
& \\ \hline
6 & TAP\_WIN\_IOCTL\_SET\_MEDIA\_STATUS & ULONG & NULL & Setzt das Gerät in den ''Up'' oder ''Down''-Zustand & \\ \hline
7 & TAP\_WIN\_IOCTL\_CONFIG\_DHCP\_MASQ & IPADDR[4] (4*4 CHAR) & NULL & Aktiviert den internen DHCP-Server, DHCP-IP-Adresse, DHCP-Netzmaske, DHCP-Server-IP, Leasetime & \\ \hline
8 & TAP\_WIN\_IOCTL\_GET\_LOG\_LINE & allokierter String (char *) & NULL & Gibt eine Debug-Log-Zeile zurück & \\ \hline
9 & TAP\_WIN\_IOCTL\_CONFIG\_DHCP\_SET\_OPT & char[256] & NULL & Setzt die DHCP-Optionen & \\ \hline
10 & TAP\_WIN\_IOCTL\_CONFIG\_TUN & IPADDR[3] (3*4 char) & NULL & Setzt das Gerät in den TUN-Modus, lokale IP, entferntes Netzwerk, entfernte Netzmaske & \\ \hline
11 & TAP\_WIN\_IOCTL\_CONFIG\_SET\_SRC\_CHECK & ULONG & NULL & Deaktiviert oder Aktiviert den ARP-Source-Check. ''0'' deaktiviert ihn. ''1'' aktiviert ihn (Standard) & \\ \hline
\end{tabularx}
\caption{TAP-Windows-Treiber IOCtls}
\label{fig:tap-ioctls}
\end{table}

\paragraph{Patch}
Bei der Entwicklung des Patchs wurde viel Zeit darauf verwendet die funktionalen
Komponenten zu finden, die bei der Verarbeitung von \ac{ARP}-Requests ausgeführt werden,
sowie die Codepfade zu finden, die bei der Verarbeitung von Daten abgelaufen werden.

Der entwickelte Patch deaktiviert die Überprüfung der Quell-IP der \ac{ARP}-Requests, die
vom Treiber verarbeitet werden. Wenn die Überprüfung erfolgreich war, so wird der ARP-Request
beantwortet und dem Kernel wird damit mitgeteilt, wie die MAC-Adresse des virtuellen Routers lautet.

Für die Implementierung der Routen wurde die Nutzung eines virtuellen Routers gewählt,
da das Routen aller \ac{IP}-Adressen über das Gerät die \ac{ARP}-Tabelle des Clients
mehr gefüllt hätte und eine \ac{ARP}-Adressabfrage bei jeder Kommunikation mit einer neuen
\ac{IP}-Adresse zu Folge hätte.

Der Patch wurde entwickelt, indem nach der Behandlung von \ac{ARP}-Paketen im
Quellcode des Treibers gesucht wurde. Dafür wurde nach ''ARP'' und ''arp'' mittels
''grep'' im Quelltext gesucht. Dabei wurde die Funktion ''ProcessARP'' in ''src/txpath.c''
gefunden, in der \ac{ARP}-Requests verarbeitet werden. In dieser Funktion
werden verschiedene Felder des Pakets überprüft, unter anderem das ''Sender protocol address''-Feld.

Die Überprüfung des ''Sender protocol address''-Felds wurde optional gemacht, 
wobei es standardmäßig aktiviert ist. Die Kontrolle dieses
Feldes kann über ein IOCTL-Wert gesteuert werden. Der momentane Zustand der Option
wird im Adapter-Kontext des TAP-Adapters gespeichert.

Er wurde 2016-08-15 in der OpenVPN Community auf freenode im Kanale \#openvpn-meeting besprochen
und bekam ein feature-ack. Ein Code-ack steht noch aus. Das Ticket ist unter
\url{https://community.openvpn.net/openvpn/ticket/721} zu finden.

Der komplette Patch ist auf der CD unter 
''patches/tap-windows/0001-implement-source-ip-check.patch'' zu finden.


\subsection{Test des Codes}
Zum Konfigurieren und Bauen des Quellcodes wurde der folgende Befehl verwendet.
Im Testszenario wurde der Quellcode auf Linux für Windows 64-Bit cross kompiliert
und in einer \ac{VM} mit Windows 8.1 ausgeführt.
Die gebauten Binärdateien wurden über ein geteiltes Verzeichnis der \ac{VM}
zugänglich gemacht. Danach wurden sie in ''C:\textbackslash{}\textbackslash{}Users\textbackslash{}\textbackslash{}Thermi\textbackslash{}\textbackslash{}bin
kopiert und in 'cmd' mit Administratorrechten ausgeführt. 
Die nötige Dateistruktur sollte wie in Abbildung \ref{fig:Ordnerstruktur} 
auf Seite \pageref{fig:Ordnerstruktur} aussehen.

Im Unterordner ''swanctl'' befindet sich die Dateien ''swanctl.conf'',
sowie die Ordner ''bliss'', ''ecdsa'', ''pkcs8'', ''pkcs12'', ''pubkey'', ''rsa'', ''x509'',
''x509aa'', ''x509ac'', ''x509ca'', ''x509crl'' und''x509ocsp''.
Im Ordner ''rsa'' befindet sich der private Schlüssel für den Client. Im Ordner
''x509'' befindet sich das Zertifikat des Clients und im Ordner ''x509ca'' alle
\ac{CA}-Zertifikate vom Zertifikat des Clients bis zum selbstsignierten Wurzelzertifikat,
sowie das Zertifikat der Server-\ac{CA}.

\begin{figure}
\def\svgwidth{\columnwidth}
\includegraphics[width=\textwidth]{CA-Struktur.eps}
\caption{Eine exemplarische CA-Struktur}
\label{fig:CA-Struktur}
\end{figure}

Die Datei ''this\_log'' wurde von der Logger-Konfiguration des Dienstes erstellt.
Hierbei wurde zuerst ''charon-svc.exe''
in einem ersten Fenster ausgeführt. In einem zweiten Fenster wurde die Konfiguration geladen
und der Tunnelaufbau mittels ''swanctl.exe'' gestartet. Hierbei wurden die folgenden
Befehle verwendet: ''swanctl.exe --load-all'' und ''swanctl --i --child bar''.
Nach dem Testen wurde der Tunnel, sollte ''charon-svc.exe'' nicht gecrasht sein, mit ''swanctl -t --ike foo''
beendet, sodass keine virtuellen IP-Adressen oder Routen für den nächsten Test zurückbleiben.

Wenn ''charon-svc.exe'' getötet wird, während ein Tunnel mit Routen und \ac{IP}-Adressen
aufgebaut ist, so verbleiben IP-Adressen und Routen auf dem Adapter, was verhindern kann dass
dieselben Routen und \ac{IP}-Adressen wieder installiert werden. Das führt dazu, dass der
Aufbau der CHILD\_SA fehlschlägt und ein neuer Tunnel nicht aufgebaut werden kann.
In diesem Fall müssen sie manuell über die Nutzung von ''route delete'' oder ''netsh''
gelöscht werden oder Windows neu gestartet werden.

OpenSSL auf Windows wird für die Kryptographie benötigt und liegt nicht in den Standardsuchpfaden
für Bibliotheken und Header. Aus diesem Grund werden die Header und Bibliotheken
über LDFLAGs in Include-Pfade auf der Kommandozeile übergeben.

Die Bibliotheken von OpenSSL wurden durch die Installation von OpenVPN beschafft.
Bei der Installation von OpenVPN werden direkt die Bibliotheken von openssl mitinstalliert.

\begin{centering}
\begin{figure}
\includegraphics[width=\textwidth]{Bilder/Ordnerstruktur.png}
\caption{Ordnerstruktur nach dem Kopieren der Dateien}
\label{fig:Ordnerstruktur}
\end{figure}
\end{centering}

\begin{centering}
\begin{figure}
\includegraphics[width=\textwidth]{Bilder/Aufbau_und_swanctl_-l.png}
\caption{Ausgabe des Tunnelaufbaus und swanctl -l}
\label{fig:swanctl-l}
\end{figure}
\end{centering}

Die unter \autoref{lst:strongswan.conf} und \autoref{lst:swanctl.conf} bereitgestellten
Konfigurationen wurden zur Konfiguration des Dienstes genutzt.


\begin{lstlisting}[caption=./configure und make]
./configure --host=x86_64-w64-mingw32 --prefix=/ --libdir=/bin --bindir=/bin --sbindir=/bin --disable-defaults --enable-monolithic --enable-static --enable-svc --enable-ikev2 
--enable-ikev1 --enable-nonce --enable-pem --enable-pkcs1 --enable-x509 --enable-openssl --enable-socket-win --enable-kernel-wfp --enable-kernel-iph --enable-pubkey --enable-swanctl 
--with-swanctldir=swanctl --with-strongswan-conf=strongswan.conf --enable-libipsec --enable-kernel-libipsec --enable-eap-tls --enable-mschapv2 --enable-eap-peap --enable-eap-gtc 
--enable-eap-dynamic --enable-eap-identity --enable-md4 --enable-ipseckey --enable-dnscert --enable-files --enable-sha3 host_alias=x86_64-w64-mingw32 CC=x86_64-w64-mingw32-gcc 
CFLAGS=-g -O2 -Wall -Werror -Wno-pointer-sign -Wno-format-security -Wno-format -mno-ms-bitfields -I/home/thermi/FH-Stuff/UNITS-8/Bachelorarbeit/win32-headers/files/include/ 
LDFLAGS=-L/home/thermi/FH-Stuff/UNITS-8/Bachelorarbeit/win32-headers/files/lib/ -L/home/thermi/FH-Stuff/UNITS-8/Bachelorarbeit/win32-headers/files/bin/
make clean && make
\end{lstlisting}


Der Befehl konfiguriert den strongSwan Quellcode zum Bauen der benötigten Plugins, sowie einiger
Extras für die Authentifizierung und dazu den 64-Bit Compiler des MINGW32-Projekts zu nutzen.

Der Code wurde getestet, indem versucht wurde eine VPN-Verbindung zu einem \ac{IKE}-Peer
unter meiner Kontrolle aufzubauen. Der ausgehandelte \ac{TS} wurde so gewählt, dass
die Beschränkung von Route based VPNs keine Rolle spielen.
Die genutzte Konfiguration ist im Appendix unter \autoref{lst:swanctl.conf}
und \autoref{lst:strongswan.conf} zu finden.

\subsection{Test der Verbindung}
Das Testen der Verbindung wurde durch durch einfaches Pingen über die Verbindung bewerkstelligt.
Dabei wird durch Dumpen der Pakete mit tcpdump und Wireshark überprüft, ob die
ARP requests auf dem TUN-Adapter beantwortet werden und ob das Paket auf dem
anderen Endpunkt auftaucht. Des weiteren werden die Traffic-Counter der \acp{SA} überprüft,
um zu überprüfen, ob die Pakete jemals verarbeitet wurden.

\subsection{Notwendige Features für Nutzung als RW auf Windows}
Um strongSwan als \ac{RW} auf Windows benutzbar zu machen werden neben dem Implementieren
der Unterstützung von TAP-Geräten unter anderem die Unterstützung der Installation von DNS-Resolvereinträgen
benötigt, da in der Regel interne DNS-Server an die \acp{RW} über Config Mode oder \acp{CP}
gesendet werden, die sie nutzen sollen.

Des weiteren wird eine Möglichkeit benötigt, um über \ac{VICI} nach Daten für dynamisch auftretende
Passwortaufforderungen, die bei der Authentifizierung mittels XAUTH oder EAP auftreten können,
zu fragen. Dies wird für die vollständige Unterstützen von \ac{MFA} benötigt.

Auf Windows benutzt das Tool ''swanctl'', welches dort zum Kontrollieren des Daemons
genutzt wird, eine TCP-Verbindung über 127.0.0.1:4502 um mit dem Daemon zu kommunizieren.
Dies ist im Vergleich zur Implementierung auf anderen Plattformen unsicher, da dort
UNIX-Sockets genutzt werden, die standardmäßig aufgrund der \acp{ACL} abgesichert werden
und nur ''root'' auf den Socket zugreifen kann. Der Wiki-Artikel macht auf die Unsicherheit
des \ac{VICI}-Protokolls, welches zwischen ''swanctl'' und ''charon'' gesprochen wird, besonders aufmerksam.
\begin{quote}
The VICI protocol runs over a reliable transport protocol. As the protocol itself currently does not provide any security or authentication properties, it is recommended to run it over a UNIX socket with appropriate permissions.
\end{quote}\cite[][]{_vici_2016}

\subsection{Probleme}
Die implementierte Lösung funktioniert im Moment noch nicht. Das Problem ist, dass
die Windows-eigenen Funktionen nicht wie dokumentiert funktionieren.
Wie erläutert wird WaitForMultipleObjects() genutzt, um die IO-Operationen
zu multiplexen. Diese Funktion beendet im Programmcode mit dem Wert ''1'',
was bedeuted dass das zweite Objekt (In C werden Arrays von 0 auf indexiert.)
im Array signalisiert wurde. Bei der Überprüfung mit WaitForSingleObject() ist das jedoch nicht
der Fall. Wenn das Event signalisiert wäre, dann würde der folgende Aufruf
den Wert ''WAIT\_OBJECT\_0'' (0x0) zurückgeben:
\begin{lstlisting}
WaitForSingleObject(event_array[offset], 0)
\end{lstlisting}]
Das ist jedoch nicht der Fall. Der Aufruf beendet mit ''WAIT\_TIMEOUT'' (0x102, 258),
was bedeuted, dass das Event nicht signalisiert ist. Wenn der Rückgabewert
ignoriert wird, dann befindet sich im Puffer kein valides IPv4-Packet.

Das Problem ist besonders evident bei der Betrachtung des Debug-Logs,
welches sich auf Seite \pageref{lst:debug-log} finden lässt.
Es wird vom Code in auf Seite \pageref{lst:handle-plain-windows} ausgegeben.

Des weiteren gibt die Funktion ''GetLastError()'' den Fehlerwert 0 zurück, wenn sie nicht
direkt nach dem Funktionsaufruf, der den Fehlerstatus setzte, aufgerufen wird.
Es ist irrelevant, ob zwischen dem Aufruf von ''GetLastError()'' nur eine einfache Zuweisung
oder eine If-Abfrage steht.
Dies ergibt keinen Sinn, da sich der Fehlerstatus scheinbar ändert, ohne dass
eine Funktion aufgerufen wird, die das tun könnte.
