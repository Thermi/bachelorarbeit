% This file is part of Bachelorarbeit

% Bachelorarbeit is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License version 3 as published by
% the Free Software Foundation.

% Bachelorarbeit is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.

% You should have received a copy of the GNU General Public License
% along with Foobar. If not, see <http://www.gnu.org/licenses/>.
\section{Portierung von libipsec auf Windows}
Die Portierung von libipsec auf Windows, sodass sie dort lauffähig ist, ist das Ziel
der Bachelorarbeit. Die zu portierenden Teile des Programmcodes betreffen nur
die Codesegmente, die Plattformspezifische \acp{API} oder \acp{ABI} verwenden,
also primär alles um Dateiein- und ausgabe, sowie das verwalten von TUN-Geräten.
Unter Unix und Linux werden hier \acp{FD} verwendet. Unter Windows werden stattdessen
Handles genutzt, welche einen anderen Dateityp darstellen. Des weiteren unterscheidet
sich die Methode zum Multiplexen von Lese-Aufrufen einer Liste von Dateien stark.
Unter Unix und Linux wird hierfür poll() genutzt, unter Windows geschieht das jedoch
Event-basiert mit WaitForMultipleObjects().
Explizite Beispiele hierfür sind im Abschnitt über die Portierung von libipsec sichtbar.
Bei der Portierung wurde für das verwalten von Speicherabschnitten 
primär alloca() genutzt, statt malloc() und seine Unterarten. Der Unterschied hierbei ist die
Speicherdauer. Mit alloca() allokierter Speicher ist nur bis zum Verlassen der Funktion gültig
und wird automatisch freigegeben. Mit malloc() allokierter Speicher muss manuell freigegeben werden.

\subsection{Bestehende Implementierung}
Die bestehende Implementierung umfasst die eigentliche Bibliothek, eine Implementierung
eines Kernel-Interface zwischen libipsec und charon, sowie Code in libstrongswan
um TUN-Geräte zu öffnen.
\subsubsection{libipsec}
libipsec implementiert die Verarbeitung von Paketen, das Erzwingen der \acp{SP},
das Verwalten der \acp{SP}, \acp{SA}, Routen und der TUN-Geräte.
Die hierbei relevanten Dateien sind unter /src/libipsec/ zu finden.

% route installation
% queues
% processing
% event driven
% job
\subsubsection{kernel-libipsec}
Die hier zu portierenden Bestandteile waren ausschließlich Codeteile, die
sich mit der Dateiein- und ausgabe beschäftigten.

Die primäre Aufgabe hier war die Installation der Routen in ''kernel\_libipsec\_ipsec.c''
für Windows anzupassen, da hier ein Gateway verwendet wird auf einem TAP-Gerät
statt ein echtes TUN-Gerät, sowie die Anpassung des Codes für die Ein- und Ausgabe 
und einige Methoden in
''kernel\_libipsec\_router.c'', da das Multiplexen der Handles, sowie die Benachrichtigung
von anderen Threads auf Windows anders abläuft als auf Linux und Unix.

Für das Multiplexen der Eingabe stehen unter Windows zwei Verfahren zur Verfügung:
\begin{itemize}
\item WaitForMultipleObjects
\item IOCompletionPorts
\end{itemize}

WaitForMultipleObjects funktioniert mit einem Array aus Handles. In der Struktur des Handles
ist das event-Attribut auf ein einzgartiges Event gesetzt, welches genutzt wird um
das Handle zu finden, dessen Lesevorgang abgeschlossen oder abgebrochen wurde.
% Mehr Erläuterung benötigt

IOCompletionPorts funktionieren, indem man einen IOCompletionPort mit CreateIoCompletionPort()
anlegt und Handles mit ihm asoziiert. Bei der Asoziierung wird ein einzigartiger Schlüssel
übergeben, der bei der Signalisierung wieder zurückgegeben wird um das Handle identifizieren zu können.
Der CompletionPort kann erst nach dem Schließen der asoziierten Handles geschlossen werden.
% Mehr Erläuterung benötigt

Da es relativ einfach ist WaitForMultipleObjects() zu nutzen, habe ich diese Methode
für die Implementierung von handle\_plain() genutzt.



% libipsec router
% handle_plain
% notification event
% job
% handle_plain
% handle_esp
% up
% destroy
%kernel_libipsec_ipsec route installation
\subsubsection{libstrongswan}
Hier galt es das Öffnen, Konfigurieren und Schließen von TUN-Geräten
mit dem TAP-Treiber zu implementieren.
% Bezugsquelle für den Treiber
% callbacks
% synchronous
% WaitForMultipleObjects
% IoCompletionPort inkompatibel mit synchroner I/O -> kompletter Rewrite?
% komplexe Änderungen des Verhaltens von kernel-libipsec

\subsubsection{kernel-iph}
% address installation
% route installation
\subsection{Portierung}
\subsubsection{Überlegungen zur Portierung}
\subsection{Unterstützte Kryptographie}
\subsection{Tun-Treiber}
% openvpn
% kompatibilität
% Treiber-patches upstream
Im Zuge der \ac{BA} wurde ein Patch für den TAP-Windows-Treiber entwicklelt, um die
Prüfung der Quell-IP der ARP-Requests zu deaktivieren. Das ist erforderlich, um mit der
virtuellen IP des Clients mit dem entfernten IP-Netzwerk kommunizieren zu können.
Das liegt daran, dass der TAP-Windows-Treiber ein Ethernet-Gerät darstellt und damit
vor der Übertragung der IP-Pakete vom Client zum Treiber die MAC-Adresse des virtuellen Routers bekannt sein muss.
Das wird, wie in jedem herkömmmlichen IP-Netzwerk auf Ethernet-Basis, mit ARP bewerkstelligt.
Die MAC-Adresse des virtuellen Routers hängt von der GUID des Adapters ab, welche zufällig ist
und bei der Erstellung des Adapters initialisiert wird. Die MAC-Adresse kann auch über die Registry verändert werden.
\paragraph{Treiberverhalten}

\paragraph{Betriebsmodi}
Der TAP-Treiber beherrscht drei verschiedene Betriebsmodi für verschiedene Zwecke.
Laut dem Quellcode des Treibers ist der Point-To-Point-Modus veraltet.
\begin{description}
\item [TUN-Modus] Im TUN-Modus schneidet der Treiber den Ethernet-Rahmen um das IP-Paket ab
und reicht das Paket über das Handle an die Software weiter. Pakete, die an den Treiber gegeben werden, werden um einen Ethernet-Rahmen
ergänzt, bei dem die Zieladresse die MAC-Adresse des virtuellen Adapters ist und die Quelladresse die MAC-Adresse des virtuellen Routers.
% remote subnet, local subnet, local IP
\item [TAP-Modus] Im TAP-Modus kopiert der Treiber jeden Ethernet-Paket zwischen Anwendung und Gerät.
% remote subnet, local subnet, local IP
\item [Point-To-Point-Modus]
\end{description}
\paragraph{Patch}
Der entwickelte Patch deaktiviert die Überprüfung der Quell-IP der ARP-Requests, die
vom Treiber verarbeitet werden. Wenn die Überprüfung erfolgreich war, so wird der ARP-Request
beantwortet und dem Kernel wird damit mitgeteilt, wie die MAC-Adresse des virtuellen Routers lautet.

Für die Implementierung der Routen wurde die Nutzung eines virtuellen Routers gewählt,
da das Routen aller \ac{IP}-Adressen über das Gerät die \ac{ARP}-Tabelle des Clients
mehr gefüllt hätte und eine \ac{ARP}-Adressabfrage bei jeder Kommunikation mit einer neuen
\ac{IP}-Adresse zu Folge hätte.

\subsection{Maßnahmen gegen Buffer Bloat}
libipsec speichert die empfangenen Pakete vor- und nach der Verarbeitung in einer Wartschleife (Queue).
Nach der Verarbeitung werden die Pakete nochmals gepuffert, bevor sie an das TUN-Gerät oder den Sockel
weitergegeben werden. Wenn die Pakete langsamer verarbeitet oder verschickt werden als sie eintreffen,
dann wächst der Puffer, bis der Anwendung (oder dem Computer) der Speicher ausgeht. Dann stürzt die Anwendung ab.
Um das zu verhindern hat Martin Willi eine Controlled-Delay-Queue implementiert und im Git-Zweig libipsec-queue\footnote{\url{https://git.strongswan.org/?p=strongswan.git;a=shortlog;h=refs/heads/libipsec-queue}} eine komplette Implementierung der Queue in libipsec abgelegt.
Die Queue verwirft Pakete wenn die Verzögerung zwischen der Ankunft und der Verarbeitung
des letzten Pakets zu groß ist.
