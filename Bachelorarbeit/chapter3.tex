% This file is part of Bachelorarbeit

% Bachelorarbeit is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License version 3 as published by
% the Free Software Foundation.

% Bachelorarbeit is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.

% You should have received a copy of the GNU General Public License
% along with Foobar. If not, see <http://www.gnu.org/licenses/>.
\section{Portierung von libipsec auf Windows}
Die Portierung von libipsec auf Windows, sodass sie dort lauffähig ist, ist das Ziel
der Bachelorarbeit. Die zu portierenden Teile des Programmcodes betreffen nur
die Codesegmente, die Plattformspezifische \acp{API} oder \acp{ABI} verwenden,
also primär alles um Dateiein- und ausgabe, sowie das verwalten von TUN-Geräten.
Unter Unix und Linux werden hier \acp{FD} verwendet. Unter Windows werden stattdessen
Handles genutzt, welche einen anderen Dateityp darstellen. Des weiteren unterscheidet
sich die Methode zum Multiplexen von Lese-Aufrufen einer Liste von Dateien stark.
Unter Unix und Linux wird hierfür poll() genutzt, unter Windows geschieht das jedoch
Event-basiert mit WaitForMultipleObjects().
Explizite Beispiele hierfür sind im Abschnitt über die Portierung von libipsec sichtbar.
Bei der Portierung wurde für das verwalten von Speicherabschnitten 
primär alloca() genutzt, statt malloc() und seine Unterarten. Der Unterschied hierbei ist die
Speicherdauer. Mit alloca() allokierter Speicher ist nur bis zum Verlassen der Funktion gültig
und wird automatisch freigegeben. Mit malloc() allokierter Speicher muss manuell freigegeben werden.
alloca() ist ein Feature, welches nicht standardisiert ist.
Daher lässt sich strongSwan nicht mit allen C-Bibliotheken übersetzen.
Auf der Wiki-Seite über den Windows-Port steht explizit geschrieben, dass nur die Kompilierung
mittels MinGW-W64 unterstützt wird.


\subsection{Bestehende Implementierung}
Die bestehende Implementierung umfasst die eigentliche Bibliothek, eine Implementierung
eines Kernel-Interface zwischen libipsec und charon, sowie Code in libstrongswan
um TUN-Geräte zu öffnen. Martin Willi hat 2014 bereits die gesamte Portierungsarbeit
für version 5.2.0 von strongSwan gemacht. Der Port unterstützt Windows 7 / server 2008 R2
und neuer.

\subsection{Unterstützte Kryptographie}
Die unterstützte Kryptographie ist notwendigerweise von den deklarierten Identifikatoren
für IKE beschränkt. strongSwan unterstützt mehr Verschlüsselungsalgorithmen als
in den \acp{RFC} deklariert wurde. Aus diesem Grund nutzt strongSwan Identifikatoren
teilweise aus dem privaten Bereich, wenn die Identifikatoren für den eingesetzten Algorithmus
nicht standardisiert sind.

strongSwan unterstützt eine große Anzahl von Algorithmen im Vergleich zu anderen Implementierungen,
wie in den Tabellen in \autoref{sec:appendix} dagelegt wird. Wenn libipsec genutzt wird,
so können alle Algorithmen, die im Userspace implementiert sind, für die Absicherung
von Verkehr genutzt werden.

\subsection{Portierung}
\subsubsection{libipsec}
libipsec implementiert die Verarbeitung von Paketen, das Erzwingen der \acp{SP},
das Verwalten der \acp{SP}, \acp{SA}, Routen und der TUN-Geräte.
Die hierbei relevanten Dateien sind unter /src/libipsec/ zu finden.

Standardmäßig installiert strongSwan die IP-Adressen die per Config-Mode
oder \ac{CP} empfangen wird auf dem ausgehenden Interface (Linux, Kernelspace processing),
was für die Kommunikation mit dem Peer genutzt wird,
oder auf dem loopback-Adapter (Windows).
Um die IP-Adresse für TUN-Geräte korrekt zu setzen, nutzt libipsec den Parameter
"charon.install\_virtual\_ip\_on" von strongswan.conf, der während der Initialisierung
des Plugins gesetzt wird.
% route installation
% queues
% processing
% event driven
% job
\subsubsection{kernel-libipsec}
Die hier zu portierenden Bestandteile waren ausschließlich Codeteile, die
sich mit der Dateiein- und ausgabe beschäftigten.

Die primäre Aufgabe hier war die Installation der Routen in ''kernel\_libipsec\_ipsec.c''
für Windows anzupassen, da hier ein Gateway verwendet wird auf einem TAP-Gerät
statt ein echtes TUN-Gerät, sowie die Anpassung des Codes für die Ein- und Ausgabe 
und einige Methoden in
''kernel\_libipsec\_router.c'', da das Multiplexen der Handles, sowie die Benachrichtigung
von anderen Threads auf Windows anders abläuft als auf Linux und Unix.

Für das Multiplexen der Eingabe stehen unter Windows zwei Verfahren zur Verfügung:
\begin{itemize}
\item WaitForMultipleObjects
\item IOCompletionPorts
\end{itemize}

WaitForMultipleObjects\footcite[][]{_waitformultipleobjects_2016} funktioniert mit einem Array aus Handles. In der Struktur des Handles
ist das event-Attribut auf ein einzgartiges Event gesetzt, welches genutzt wird um
das Handle zu finden, dessen Lesevorgang abgeschlossen oder abgebrochen wurde.
Nach dem Kopieren des Handles in das Array und dem Setzen des Events wird ein asynchroner
Lesevorgang gestartet. Wenn er sofort beendet wurde, wird das entsprechende Event gesetzt.
Dadurch beendet der Aufruf von WaitForMultipleObjects() nach dem aufruf direkt, falls
ein Lesevorgang schon zuvor erfolgreich war und der Programmcode wird etwas kürzer.
% Mehr Erläuterung benötigt

IOCompletionPorts\footcite[][]{_createiocompletionport_2016} funktionieren, indem man einen IOCompletionPort mit CreateIoCompletionPort()
anlegt und Handles mit ihm asoziiert. Bei der Asoziierung wird ein einzigartiger Schlüssel
übergeben, der bei der Signalisierung wieder zurückgegeben wird um das Handle identifizieren zu können.
Der CompletionPort kann erst nach dem Schließen der asoziierten Handles geschlossen werden.
Mit der Funktion GetQueuedCompletionStatus() kann der ausführende Thread dann auf abgeschlossene
I/O-Operationen warten.
Die Nachteile dieser Methode sind, dass jegliche Operationen auf den Handles eine Benachrichtigung
an GetQueuedCompletionStatus() generieren, obwohl Schreib-Vorgänge nicht von Interesse sind.

% Mehr Erläuterung benötigt

Da es relativ einfach ist WaitForMultipleObjects() zu nutzen, habe ich diese Methode
für die Implementierung von handle\_plain() genutzt.

Folgend die originale Implementierung für Linux und Unix mit poll()
% Stattdessen Pseudocode?
\begin{lstlisting}[caption=Code für handle\_plain auf Unix/Linux]
/**
 * Job handling outbound plaintext packets
 */
static job_requeue_t handle_plain(private_kernel_libipsec_router_t *this)
{
	enumerator_t *enumerator;
	tun_entry_t *entry;
	bool oldstate;
	int count = 0;
	char buf[1];
	struct pollfd *pfd;

	this->lock->read_lock(this->lock);

	pfd = alloca(sizeof(*pfd) * (this->tuns->get_count(this->tuns) + 2));
	pfd[count].fd = this->notify[0];
	pfd[count].events = POLLIN;
	count++;
	pfd[count].fd = this->tun.fd;
	pfd[count].events = POLLIN;
	count++;

	enumerator = this->tuns->create_enumerator(this->tuns);
	while (enumerator->enumerate(enumerator, NULL, &entry))
	{
		pfd[count].fd = entry->fd;
		pfd[count].events = POLLIN;
		count++;
	}
	enumerator->destroy(enumerator);
	this->lock->unlock(this->lock);

	oldstate = thread_cancelability(TRUE);
	if (poll(pfd, count, -1) <= 0)
	{
		thread_cancelability(oldstate);
		return JOB_REQUEUE_FAIR;
	}
	thread_cancelability(oldstate);

	if (pfd[0].revents & POLLIN)
	{
		/* list of TUN devices changed, read notification data, rebuild FDs */
		while (read(this->notify[0], &buf, sizeof(buf)) == sizeof(buf))
		{
			/* nop */
		}
		return JOB_REQUEUE_DIRECT;
	}

	if (pfd[1].revents & POLLIN)
	{
		process_plain(this->tun.tun);
	}

	this->lock->read_lock(this->lock);
	enumerator = this->tuns->create_enumerator(this->tuns);
	while (enumerator->enumerate(enumerator, NULL, &entry))
	{
		if (find_revents(pfd, count, entry->fd) & POLLIN)
		{
			process_plain(entry->tun);
		}
	}
	enumerator->destroy(enumerator);
	this->lock->unlock(this->lock);

	return JOB_REQUEUE_DIRECT;
}
\end{lstlisting}

Folgend die Implementierung mit WaitForMultipleObjects()
\begin{lstlisting}[caption=Code für handle\_plain auf Windows]
static job_requeue_t handle_plain(private_kernel_libipsec_router_t *this)
{
        DBG1(DBG_LIB, "entered handle_plain.");
        void **key = NULL;
        bool oldstate, status;
        uint32_t length, event_status = 0, i = 0, j = 0;
        handle_overlapped_buffer_t *bundle_array = NULL, dummy, tun_device_handle_overlapped_buffer, *structures = NULL;
        OVERLAPPED *overlapped = NULL;
        HANDLE *event_array = NULL, tun_device_event;
        tun_device_t *tun_device = this->tun.tun;
        enumerator_t *tuns_enumerator;

        memset(&tun_device_handle_overlapped_buffer, 0, sizeof(handle_overlapped_buffer_t));
        /* Reset synchronisation event */
        ResetEvent(this->event);

        length = this->tuns->get_count(this->tuns);

        this->lock->read_lock(this->lock);
        /* Read event for this->tun */

        /* allocate arrays for all the structs we need */
        /* events, overlapped structures and bundles. */
        /* event_array holds all the HANDLE structures for the events that are
         * used for notifying the thread of finished reads and writes.
         */

        overlapped = alloca((length+2)*sizeof(OVERLAPPED));
        event_array = alloca((length+2)*sizeof(HANDLE));
        bundle_array = alloca((length+2)*sizeof(handle_overlapped_buffer_t));

        memset(overlapped, 0, (length+2)*sizeof(OVERLAPPED));
        memset(bundle_array, 0, (length+2)*sizeof(handle_overlapped_buffer_t));

        DBG1(DBG_LIB, "Allocated arrays, opened events");

        /* These are the arrays we're going to work with */

        /* first position is the event we use for synchronisation  */
        /* Insert notification event */
        event_array[i] = this->event;
        /* Insert dummy structure */
        bundle_array[i] = dummy;
        i++;

        /* second position is this->tun */
        /* insert event object for this->tun device */
        tun_device_event = CreateEvent(NULL, FALSE, FALSE, this->tun.tun->get_read_event_name(this->tun.tun));
        if (!tun_device_event)
        {
            DWORD error = GetLastError();
            char *lpMsgBuf;
            FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_FROM_SYSTEM |
                FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                error,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPTSTR) &lpMsgBuf,
                0, NULL );
            DBG1(DBG_LIB, "Error: %s", lpMsgBuf);
            raise(SIGTERM);
        }
        event_array[i] = tun_device_event;
        ResetEvent(event_array[i]);
        /* bundle for the read on this->tun */
        /* Reserve memory for the buffer*/
        tun_device_handle_overlapped_buffer.buffer = chunk_alloca(tun_device->get_mtu(tun_device));
        DBG1(DBG_LIB, "Allocated buffer.");
        tun_device_handle_overlapped_buffer.fileHandle = tun_device->get_handle(tun_device);
        DBG1(DBG_LIB, "Allocated file handle.");
        tun_device_handle_overlapped_buffer.overlapped = overlapped;
        DBG1(DBG_LIB, "Allocated overlapped..");
        /* Fill in code */
        tun_device_handle_overlapped_buffer.overlapped->hEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, this->tun.tun->get_read_event_name(this->tun.tun));
        if (tun_device_handle_overlapped_buffer.overlapped->hEvent == NULL)
        {
            DWORD error = GetLastError();
            char *lpMsgBuf;
            FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_FROM_SYSTEM |
                FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                error,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPTSTR) &lpMsgBuf,
                0, NULL );
            DBG1(DBG_LIB, "Error: %s", lpMsgBuf);
            raise(SIGTERM);
        }
        DBG1(DBG_LIB, "Created event");
        bundle_array[i] = tun_device_handle_overlapped_buffer;

        DBG1(DBG_LIB, "%d", tun_device_handle_overlapped_buffer.buffer.ptr[1499]);
        DBG1(DBG_LIB, "handle: %d", tun_device_handle_overlapped_buffer.fileHandle);
        DBG1(DBG_LIB, "%d", tun_device_handle_overlapped_buffer.overlapped->hEvent);
        i++;

        /* Start ReadFile for this->tun.handle */
        status = ReadFile(tun_device_handle_overlapped_buffer.fileHandle,
            tun_device_handle_overlapped_buffer.buffer.ptr,
            tun_device_handle_overlapped_buffer.buffer.len,
            NULL,
            tun_device_handle_overlapped_buffer.overlapped );
        if (status)
        {
            SetEvent(tun_device_handle_overlapped_buffer.overlapped->hEvent);
        }
        else
        {
            DWORD error = GetLastError();
            switch(error)
            {
                case ERROR_IO_PENDING:
                    /* IO enqueud. Everything's fine. */
                    break;
                case ERROR_INVALID_USER_BUFFER:
                case ERROR_NOT_ENOUGH_MEMORY:
                    /* too many outstanding I/O requests
                     * We can't fix that and need to stop the process
                     */
                    DBG1(DBG_LIB, "the operating system did not allow us to enqueue more asynchronous operations");
                    this->lock->unlock(this->lock);
                    raise(SIGTERM);
                    /* fatal error */
                    break;
                case ERROR_NOT_ENOUGH_QUOTA:
                    /* unable to page lock calling process's buffer */
                    DBG1(DBG_LIB, "the operating system could not lock the buffer");
                    this->lock->unlock(this->lock);
                    /* fatal error */
                    raise(SIGTERM);
                    break;
                default:
                    DBG1(DBG_LIB, "Unknown error %d occured", error);
                    /* Some error we don't know */
                    /* exit */
                    /* TODO: Translate error number to human readable*/
                    /* fatal error */
                    raise(SIGTERM);
                    break;
            }

        }
        /* pad bundle_array with two empty structures */
        /* iterate over all our tun devices, create event handles, reset them, queue read operations on all handles */

        DBG1(DBG_LIB, "Enumerating tun devices ...");

        tuns_enumerator = this->tuns->create_enumerator(this->tuns);
        while(tuns_enumerator->enumerate(tuns_enumerator, key, &tun_device))
        {
            /* Allocate structure and buffer */

            structures[j].buffer = chunk_alloca(tun_device->get_mtu(tun_device));
            structures[j].fileHandle = tun_device->get_handle(tun_device);
            /* Allocate and initialise OVERLAPPED structure */
            structures[j].overlapped = alloca(sizeof(OVERLAPPED));
            (*structures[j].overlapped) = overlapped[j];
            memset(&structures[j].overlapped, 0, sizeof(OVERLAPPED));
            /* Create unique name for that event. */
            /* Create unique event for read accesses on that device
             * No security attributes, no manual reset, initial state is unsignaled,
             * name is the special name we created
             */
            structures[j].overlapped->hEvent = CreateEvent(NULL, FALSE, FALSE, tun_device->get_read_event_name(tun_device));
            event_array[i] = OpenEvent(EVENT_ALL_ACCESS, FALSE, tun_device->get_read_event_name(tun_device));
            bundle_array[i] = structures[j];

            if (event_array[i] == NULL)
            {
                DWORD error = GetLastError();
                char *lpMsgBuf;
                FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_SYSTEM |
                    FORMAT_MESSAGE_IGNORE_INSERTS,
                    NULL,
                    error,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                    (LPTSTR) &lpMsgBuf,
                    0, NULL );
                DBG1(DBG_LIB, "Error: %s", lpMsgBuf);
                raise(SIGTERM);
            }
            i++;

            /* Initialise read with the allocate overwrite structure */
            DBG1(DBG_LIB, "Reading on %s", tun_device->get_name(tun_device));
            status = ReadFile(structures[j].fileHandle, structures[j].buffer.ptr,
                    structures[j].buffer.len, NULL, structures[j].overlapped);
            if (status)
            {
                /* Read returned immediately */
                /* We need to signal the event ourselves */

                SetEvent(event_array[i]);
                continue;
            }
            else
            {
                DWORD error = GetLastError();
                switch(error)
                {
                    case ERROR_IO_PENDING:
                        /* IO enqueud. Everything's fine. */
                        break;
                    case ERROR_INVALID_USER_BUFFER:
                    case ERROR_NOT_ENOUGH_MEMORY:
                        /* too many outstanding I/O requests
                         * We can't fix that and need to stop the process
                         */
                        DBG1(DBG_LIB, "the operating system did not allow us to enqueue more asynchronous operations");
                        this->lock->unlock(this->lock);
                        raise(SIGTERM);
                        /* fatal error */
                        break;
                    case ERROR_NOT_ENOUGH_QUOTA:
                        /* unable to page lock calling process's buffer */
                        DBG1(DBG_LIB, "the operating system could not lock the buffer");
                        this->lock->unlock(this->lock);
                        /* fatal error */
                        raise(SIGTERM);
                        break;
                    default:
                        DBG1(DBG_LIB, "Unknown error %d occured", error);
                        /* Some error we don't know */
                        /* exit */
                        /* TODO: Translate error number to human readable*/
                        /* fatal error */
                        raise(SIGTERM);
                        break;
                }
            }
            j++;
        }
        tuns_enumerator->destroy(tuns_enumerator);

        this->lock->unlock(this->lock);

        while(TRUE)
        {
            /* Wait for a handle to be signaled */
            /* In the mingw64 sources, MAXIMUM_WAIT_OBJECTS is defined as 64. That means we can wait for a maximum of 64 event handles.
             * This translates to 63 tun devices. I think this is sufficiently high to not have to implement a mechanism for waiting for more
             * events /support more TUN devices */
            oldstate = thread_cancelability(FALSE);
            DBG1(DBG_LIB, "Waiting for events...");
            event_status = WaitForMultipleObjects(i, event_array, FALSE, INFINITE);
            thread_cancelability(oldstate);
            DBG1(DBG_LIB, "Event triggered...");
            /* A handle was signaled. Find the tun handle whose read was successful */

            /* We can only use the event_status of indication for the first completed IO operation.
             * After the event was signaled, we need to test the OVERLAPPED structure in the other array
             * to find out what event was signaled.
             */

            if ((WAIT_OBJECT_0 < event_status) < ((WAIT_OBJECT_0 + length - 1)))
            {
                /* the event at event_array[event_status - WAIT_OBJECT_0] has been signaled */
                /* It is possible that more than one event was signalled. In that case, (event_status - WAIT_OBJECT_0)
                 * is the index with the lowest event that was signalled. More signalled events can be found higher
                 */
                DWORD offset = event_status - WAIT_OBJECT_0;
                if (offset == 0)
                {
                    /* Notification about changes regarding the tun devices.
                     * We need to rebuild the array. So exit and rebuild. */
                    DBG1(DBG_LIB, "cleanup.");
                    /* Cleanup*/
                    for(uint32_t k=0;k<i;k++)
                    {
                        /* stop all asynchronous IO */
                        CancelIo(bundle_array[k].fileHandle);
                        CloseHandle(bundle_array[k].overlapped->hEvent);
                        ResetEvent(event_array[k]);
                        CloseHandle(event_array[k]);
                    }
                    /* exit */
                    DBG1(DBG_LIB, "Cleanup done.");
                    return JOB_REQUEUE_FAIR;
                }
                for(uint32_t k=1;k<i; k++)
                {
                    /* Is the object signaled? */
                    DBG1(DBG_LIB, "checking if event is signaled.");
                    if (WaitForSingleObject(event_array[k], 0) == WAIT_OBJECT_0)
                    {
                        /* The arrays have the same length and the same positioning of the elements.
                         * Therefore, if event_array[k] is signaled, the read on bundle_array[i].fileHandle has succeeded
                         * and bundle_array[k].buffer has our data now. */

                        /* Do we need to copy the chunk before we enqueue it? */
                        DBG1(DBG_LIB, "Event is signaled. Processing packet.");
                        ip_packet_t *packet;
                        packet = ip_packet_create(bundle_array[k].buffer);
                        if (packet)
                        {
                                ipsec->processor->queue_outbound(ipsec->processor, packet);
                        }
                        else
                        {
                                DBG1(DBG_KNL, "invalid IP packet read from TUN device");
                        }
                        /* Reset the overlapped structure, event and buffer */
                        memset(&bundle_array[k].overlapped, 0, sizeof(OVERLAPPED));
                        /* Don't leak packets */
                        memset(bundle_array[k].buffer.ptr, 0, bundle_array[k].buffer.len);

                        bundle_array[k].overlapped->hEvent = event_array[k];
                        ResetEvent(event_array[k]);

                    }
                }

            }
            /* Function failed */
            else
            {
                DBG1(DBG_LIB, "waiting for events on the tun device reads failed.");
                /* cleanup, exit, retry */
            }
        }

        return JOB_REQUEUE_DIRECT;
}
\end{lstlisting}

% libipsec router
% handle_plain
% notification event
% job
% handle_plain
% handle_esp
% up
% destroy
%kernel_libipsec_ipsec route installation
\subsubsection{libstrongswan}
Hier galt es das Öffnen, Konfigurieren und Schließen von TUN-Geräten
mit dem TAP-Windows-Treiber zu implementieren.

% Bezugsquelle für den Treiber
Der Treiber ist kompiliert auf der OpenVPN-Seite
verfügbar\footnote{\url{https://openvpn.net/index.php/open-source/downloads.html}}
und der Quellcode auf Github\footnote{\url{https://github.com/OpenVPN}}.
Die Basis für die Implementierung war hier der existierende Programmcode in
OpenVPN, spezifisch in Datei /src/openvpn/tun.c.

Um das TAP-Gerät zu nutzen versucht der Code zuerst nach Netzwerkgeräten mit der ID "tap0901" zu suchen,
welche die ID für TAP-Geräte ist.

anach wird versucht eine Datei in \\.\\Global\/GUID.tap mittels 
\begin{lstlisting}
CreateFile(device_path, GENERIC_READ \| GENERIC_WRITE, 0,
                    0, OPEN_EXISTING, FILE_ATTRIBUTE_SYSTEM | FILE_FLAG_OVERLAPPED, 0);
\end{lstlisting}
zu öffnen.
Das Handle kann nun genutzt werden um Pakete vom TAP-Gerät zu lesen und zu schreiben.
Mittels DeviceIoControl kann die Konfiguration des Geräts geändert werden,
wie die IP des virtuellen Routers, den Status des Geräts sowie der Modus des Geräts.

Für die Portierung wurden die \acp{FD} für Handles ausgetauscht und für das Benachrichtigen
über Änderungen in der Liste der TUN-Geräte wurde ein Event verwendet.

Da Eventbasiertes IO-Multiplexing genutzt wird, werden verschiedene Events zum Lesen
und Schreiben verwendet.
Die Namen der Events werden als Attribut des Objekts in ''tun\_device\_t->read\_event\_name''
''tun\_device\_t->write\_event\_name'' gespeichert. Sie können mittles ''tun\_device\_t->get\_read\_event\_name()'
und ''tun\_device\_t->get\_read\_event\_name()'' gelesen werden.

\begin{lstlisting}[caption=Code für das Suchen eines TAP-Geräts]
/*
 * Searches through the registry for suitable TAP driver interfaces
 * On Windows, the TAP interface metadata is stored and described in the registry.
 * It returns a linked list that contains all found guids. The guids describe the interfaces.
 */

linked_list_t *get_tap_reg()
{
    HKEY adapter_key;
    LONG status;
    DWORD len;
    linked_list_t *list = linked_list_create();
    int i = 0;

    /*
     * Open parent key. It contains all other keys that
     * describe any possible interfaces.
     */
    status = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            ADAPTER_KEY,
            0,
            KEY_READ,
            &adapter_key);

    if (status != ERROR_SUCCESS)
    {
        DBG2(DBG_LIB, "Error opening registry key: %s", ADAPTER_KEY);
    }

    while (true)
    {
        char enum_name[256];
        char unit_string[256];
        HKEY unit_key;
        char component_id_string[] = "ComponentId";
        char component_id[256];
        char net_cfg_instance_id_string[] = "NetCfgInstanceId";
        char net_cfg_instance_id[256];
        DWORD data_type;

        len = sizeof (enum_name);
        status = RegEnumKeyEx(
                adapter_key,
                i,
                enum_name,
                &len,
                NULL,
                NULL,
                NULL,
                NULL);
        if (status == ERROR_NO_MORE_ITEMS)
        {
            break;
        }
        else if (status != ERROR_SUCCESS)
        {
            DBG2(DBG_LIB, "Error enumerating registry subkeys of key: %s",
                    ADAPTER_KEY);
        }

        snprintf(unit_string, sizeof (unit_string), "%s\\%s",
                ADAPTER_KEY, enum_name);

        status = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                unit_string,
                0,
                KEY_READ,
                &unit_key);

        if (status != ERROR_SUCCESS)
        {
            DBG2(DBG_LIB, "Error opening registry key: %s", unit_string);
        }
        else
        {
            len = sizeof (component_id);
            status = RegQueryValueEx(
                    unit_key,
                    component_id_string,
                    NULL,
                    &data_type,
                    component_id,
                    &len);

            if (status != ERROR_SUCCESS || data_type != REG_SZ)
            {
                DBG2(DBG_LIB, "Error opening registry key: %s\\%s",
                        unit_string, component_id_string);
            }
            else
            {
                len = sizeof (net_cfg_instance_id);
                status = RegQueryValueEx(
                        unit_key,
                        net_cfg_instance_id_string,
                        NULL,
                        &data_type,
                        net_cfg_instance_id,
                        &len);

                if (status == ERROR_SUCCESS && data_type == REG_SZ)
                {
                    if (!strcmp(component_id, TAP_WIN_COMPONENT_ID))
                    {
                        /* That thing is a valid interface key */
                        /* link into return list */
                        char *guid = malloc(sizeof(net_cfg_instance_id));
                        memcpy(guid, net_cfg_instance_id, sizeof(net_cfg_instance_id));
                        list->insert_last(list, guid);
                    }
                }
            }
            RegCloseKey(unit_key);
        }
        ++i;
    }

    RegCloseKey(adapter_key);
    return list;
}
\end{lstlisting}

Folgend ist der Code für das Konfigurieren eines TAP-Geräts:
\begin{lstlisting}[caption=Konfiguration eines TAP-Geräts]
/**
 * Initialize the tun device
 */
static bool init_tun(private_tun_device_t *this, const char *name_tmpl)
[...]
#elif defined(WIN32)
        /* WIN32 TAP driver stuff*/
        /* Check if there is an unused tun device following the IPsec name scheme*/
        enumerator_t *enumerator;
        char *guid;
        BOOL success = FALSE;
        linked_list_t *possible_devices = get_tap_reg();
        memset(this->if_name, 0, sizeof(this->if_name));

        this->read_event_name = malloc(WIN32_TUN_EVENT_LENGTH);
        this->write_event_name = malloc(WIN32_TUN_EVENT_LENGTH);
        /* Iterate over list */
        enumerator = possible_devices->create_enumerator(possible_devices);
        /* Try to open that device */
        while(enumerator->enumerate(enumerator, &guid))
        {
            if (!success){
                /* Set mode */
                char device_path[256];
                /* Translate dev name to guid */
                /* TODO: Fix. device_guid should be */
                snprintf (device_path, sizeof(device_path), "%s%s%s", USERMODEDEVICEDIR, guid, TAP_WIN_SUFFIX);

                this->tunhandle = CreateFile(device_path, GENERIC_READ | GENERIC_WRITE, 0,
                    0, OPEN_EXISTING, FILE_ATTRIBUTE_SYSTEM | FILE_FLAG_OVERLAPPED, 0);
                if (this->tunhandle == INVALID_HANDLE_VALUE)
                {
                    DBG1(DBG_LIB, "could not create TUN device %s", device_path);
                }
                else
                {
                    memcpy(this->if_name, guid, strlen(guid));
                    success = TRUE;
                }
            }
            else
            {
                break;
            }
            /* device has been examined or used, free it */
            free(guid);
        }

        /* possible_devices has been freed while going over the enumerator.
         * Therefore it is not necessary to free the elements in the list now.
         */
        enumerator->destroy(enumerator);
        possible_devices->destroy(possible_devices);
        if (!success)
        {
            return FALSE;
        }
        /* set correct mode */
        /* We set a fake gateway of 169.254.254.128 that we route packets over
         The TAP driver strips the Ethernet header and trailer of the Ethernet frames
         before sending them back to the application that listens on the handle */
	struct in_addr ep[3];
        ULONG status = TRUE;
        DWORD len;
        /* Local address (just fake one): 169.254.128.127 */
	ep[0].S_un.S_un_b.s_b1 = 169;
        ep[0].S_un.S_un_b.s_b2 = 254;
        ep[0].S_un.S_un_b.s_b3 = 128;
        ep[0].S_un.S_un_b.s_b4 = 127;
        /*
         * Remote network. The tap driver validates it by masking it with the remote_netmask
         * and then comparing hte result against the remote network (this value here).
         * If it does not match, an error is logged and initialization fails.
         * (local & remote_netmask ? local)
         * The driver does proxy arp for this network and the local address.
         */
        /* We need to integrate support for IPv6, too. */
        /* Just fake a link local address for now (169.254.128.128) */
	ep[1].S_un.S_un_b.s_b1 = 169;
        ep[1].S_un.S_un_b.s_b2 = 254;
        ep[1].S_un.S_un_b.s_b3 = 128;
        ep[1].S_un.S_un_b.s_b4 = 128;
        /* Remote netmask (255.255.255.255) */
	ep[2].S_un.S_un_b.s_b1 = 255;
        ep[2].S_un.S_un_b.s_b2 = 255;
        ep[2].S_un.S_un_b.s_b3 = 255;
        ep[2].S_un.S_un_b.s_b4 = 255;

        if(!DeviceIoControl (this->tunhandle, TAP_WIN_IOCTL_CONFIG_TUN,
		    ep, sizeof (ep),
		    ep, sizeof (ep), &len, NULL))
        {
            DBG1 (DBG_LIB, "WARNING: The TAP-Windows driver rejected a TAP_WIN_IOCTL_CONFIG_TUN DeviceIoControl call.");
        }

        ULONG disable_src_check = FALSE;
        if(!DeviceIoControl(this->tunhandle, TAP_WIN_IOCTL_CONFIG_SET_SRC_CHECK,
                    &disable_src_check, sizeof(disable_src_check),
                    &disable_src_check, sizeof(disable_src_check), &len, NULL))
        {
            DBG1 (DBG_LIB, "WARNING: The TAP-Windows driver rejected a TAP_WIN_IOCTL_CONFIG_SET_SRC_CHECK DeviceIoControl call.");
        }
        ULONG driverVersion[3] = {0 , 0, 0};
        if(!DeviceIoControl(this->tunhandle, TAP_WIN_IOCTL_GET_VERSION,
                    &driverVersion, sizeof(driverVersion),
                    &driverVersion, sizeof(driverVersion), &len, NULL))
        {
            DBG1(DBG_LIB, "WARNING: The TAP-Windows driver rejected a TAP_WIN_IOCTL_GET_VERSION DeviceIoControl call.");
        }
        else
        {
            DBG1(DBG_LIB, "TAP-Windows driver version %d.%d available.", driverVersion[0], driverVersion[1]);
        }
        /* Set device to up */

        if (!DeviceIoControl (this->tunhandle, TAP_WIN_IOCTL_SET_MEDIA_STATUS,
  			  &status, sizeof (status),
                            &status, sizeof (status), &len, NULL))
        {
            DBG1 (DBG_LIB, "WARNING: The TAP-Windows driver rejected a TAP_WIN_IOCTL_SET_MEDIA_STATUS DeviceIoControl call.");
        }

            /* Give the adapter 2 seconds to come up */
        /* Create event with special template */
        snprintf(this->read_event_name, WIN32_TUN_EVENT_LENGTH, WIN32_TUN_READ_EVENT_TEMPLATE, this->if_name);
        snprintf(this->write_event_name, WIN32_TUN_EVENT_LENGTH, WIN32_TUN_WRITE_EVENT_TEMPLATE, this->if_name);
        sleep(2);
        return TRUE;
        [...]
}
\end{lstlisting}

Für das Setzen des Geräts auf ''up'' wurde der entsprechende Aufruf per IoControl
implementiert:
\begin{lstlisting}[caption=Code für das Setzen des Geräts auf ''up'']
/* Fix for WIN32 */
METHOD(tun_device_t, up, bool,
	private_tun_device_t *this)
{
#ifdef WIN32
        ULONG status = TRUE;
        DWORD len;
        if (!DeviceIoControl (this->tunhandle, TAP_WIN_IOCTL_SET_MEDIA_STATUS,
			  &status, sizeof (status),
			  &status, sizeof (status), &len, NULL))
        {
            DBG1(DBG_LIB, "failed to set the interface %s to up", this->if_name);
            return FALSE;
        }
#else
        [...]
#endif /* WIN32 */
	return TRUE;
}
\end{lstlisting}

Folgend der Code für das Erstellen eines Objects vom Typ ''tun\_device\_t''.

\begin{lstlisting}[caption=Code für das Erstellen von tun\_device\_t]
/*
 * Described in header
 */
tun_device_t *tun_device_create(const char *name_tmpl)
{
	private_tun_device_t *this;

	INIT(this,
		.public = {
			.read_packet = _read_packet,
			.write_packet = _write_packet,
			.get_mtu = _get_mtu,
			.set_mtu = _set_mtu,
			.get_name = _get_name,
                        /* For WIN32, that's a handle. */
#ifdef WIN32
                        .get_handle = _get_handle,
                        .get_write_event_name = _get_write_event_name,
                        .get_read_event_name = _get_read_event_name,
#else
			.get_fd = _get_fd,
#endif /* WIN32 */
			.set_address = _set_address,
			.get_address = _get_address,
			.up = _up,
			.destroy = _destroy,
		},
#ifdef WIN32
                .tunhandle = NULL,
#else
		.tunfd = -1,
		.sock = -1,
#endif /* WIN32 */
	);

	if (!init_tun(this, name_tmpl))
	{
		free(this);
		return NULL;
	}
	DBG1(DBG_LIB, "created TUN device: %s", this->if_name);

#ifdef WIN32
#else
	this->sock = socket(AF_INET, SOCK_DGRAM, 0);
	if (this->sock < 0)
	{
		DBG1(DBG_LIB, "failed to open socket to configure TUN device");
		destroy(this);
		return NULL;
	}
#endif /* WIN32 */
	return &this->public;
}

#endif /* TUN devices supported */
\end{lstlisting}

\begin{lstlisting}[caption=Relevanter code für tun\_device\_t->destroy()]
METHOD(tun_device_t, destroy, void,
	private_tun_device_t *this)
{
#ifdef WIN32
        /* close file handle, destroy interface */
        CloseHandle(this->tunhandle);
        free(this->read_event_name);
        free(this->write_event_name);
#else
        [...]
#endif
    	DESTROY_IF(this->address);
    	free(this);
}
\end{lstlisting}
% callbacks
% synchronous
% WaitForMultipleObjects
% komplexe Änderungen des Verhaltens von kernel-libipsec

\subsubsection{kernel-iph}
kernel-iph ist ein Plugin für charon, das das Kernel-Interface
für die Verwaltung von IP-Adressen und Routen implementiert.

Ursprünglich war das Verwalten von IP-Adressen im Master-Zweig nicht implementiert.
Eine vollständige Implementierung existiert im Zweig "win-vip", die in den Zweig 'windows-libipsec'
gemerged wurde, um eine vollständige Implementierung dort zu erhalten.
%TODO: Codebeispiele?
Nachgerüstet werden musste Code zum Beachten des "charon.install\_virtual\_ip\_on" Parameters
der in der Datei "strongswan.conf" definiert werden kann und den libipsec nutzt um
die Installation der empfangenen IP-Adresse(n) auf den richtigen Adapter zu erzwingen.
Der Code kopiert den Adapternamen während der Initialisierung des Plugins, daher
ändert ein Ändern des Parameters während der Laufzeit nicht die Schnittstelle,
auf die die IP-Adresse installiert werden würde.

Die bekannten IP-Adressen werden in kernel-iph in einer Datenstruktur gespeichert,
um sie schnell nachschlagen zu können und Berechnungen zu tätigen. Die Struktur
wird einerseits durch manuelles Einfügen und Entfernen von selbstinstallierten Adressen
bewerkstelligt, als auch durch Events, die der Kernel per 

\begin{lstlisting}[caption=Ergänzung zu private\_kernel\_iph\_net\_t]
/**
 * Private data of kernel_iph_net implementation.
 */
struct private_kernel_iph_net_t {
        [...]
        /**
         * Whether to install virtual IPs
         */
        bool install_virtual_ip;

        /**
         * Where to install virtual IPs
         */

        char *install_virtual_ip_on;
};
\end{lstlisting}

\begin{lstlisting}[caption=Code für add\_ip]
METHOD(kernel_net_t, add_ip, status_t,
	private_kernel_iph_net_t *this, host_t *vip, int prefix, char *name)
{
	if (!this->install_virtual_ip)
	{	/* disabled by config */
		return SUCCESS;
	}
	MIB_UNICASTIPADDRESS_ROW row;
	u_long status;
        iface_t *iface = NULL, *entry = NULL;

        /* Print out all known interfaces */
        enumerator_t *enumerator = this->ifaces->create_enumerator(this->ifaces);
        while(enumerator->enumerate(enumerator, &entry))
        {
            DBG1(DBG_KNL, "interface %s\n index: %d\n description %s\n type %d", entry->ifname, entry->ifindex, entry->ifdesc, entry->iftype);
        }
        enumerator->destroy(enumerator);
	/* name of the MS Loopback adapter */
        if (!this->install_virtual_ip_on || this->ifaces->find_first(this->ifaces, (void*)iface_by_name,
						(void**)&iface, this->install_virtual_ip_on) != SUCCESS)
        {
            name = "{DB2C49B1-7C90-4253-9E61-8C6A881194ED}";
        }
        else
        {
            name = this->install_virtual_ip_on;
        }
	host2unicast(vip, prefix, &row);

	row.InterfaceIndex = add_addr(this, name, vip, TRUE);
	if (!row.InterfaceIndex)
	{
		DBG1(DBG_KNL, "interface '%s' not found", name);
		return NOT_FOUND;
	}

	status = CreateUnicastIpAddressEntry(&row);
	if (status != NO_ERROR)
	{
		DBG1(DBG_KNL, "creating IPH address entry failed: %lu", status);
		remove_addr(this, vip);
		return FAILED;
	}
	return SUCCESS;
}
\end{lstlisting}

\begin{lstlisting}[caption=Code für del\_ip]
METHOD(kernel_net_t, del_ip, status_t,
	private_kernel_iph_net_t *this, host_t *vip, int prefix, bool wait)
{
        if (!this->install_virtual_ip)
	{	/* disabled by config */
		return SUCCESS;
	}

	MIB_UNICASTIPADDRESS_ROW row;
	u_long status;

	host2unicast(vip, prefix, &row);

	row.InterfaceIndex = remove_addr(this, vip);
	if (!row.InterfaceIndex)
	{
		DBG1(DBG_KNL, "virtual IP %H not found", vip);
		return NOT_FOUND;
	}

	status = DeleteUnicastIpAddressEntry(&row);
	if (status != NO_ERROR)
	{
		DBG1(DBG_KNL, "deleting IPH address entry failed: %lu", status);
		return FAILED;
	}

	return SUCCESS;
}
\end{lstlisting}

\begin{lstlisting}[caption=Ergänzung zu kernel\_iph\_net\_create()]
*
 * Described in header.
 */
kernel_iph_net_t *kernel_iph_net_create()
{
        [...}
		.install_virtual_ip = lib->settings->get_bool(lib->settings,
						"%s.install_virtual_ip", TRUE, lib->ns),
		.install_virtual_ip_on = lib->settings->get_str(lib->settings,
						"%s.install_virtual_ip_on", NULL, lib->ns),
	   [...]
}
\end{lstlisting}

Für das Implementieren des Codes für den TAP-Treiber werden Magic Numbers benötigt,
welche sich im Quellcode von OpenVPN finden lassen. Ich habe diese feig übernommen.
Teilweise habe ich auch Konstanten für die Erzeugung der Namen der Events für
das IO-Multiplexen dort abgelegt.
\begin{lstlisting}[caption=Code von win32.h]
/*
 * Copyright (C) 2016 Noel Kuntze
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#ifndef WIN32_H
#define WIN32_H

#define WIN32_TUN_READ_EVENT_TEMPLATE "WIN32-libipsec-read-device-%d"
#define WIN32_TUN_WRITE_EVENT_TEMPLATE "WIN32-libipsec-write-device-%d"
#define WIN32_TUN_EVENT_LENGTH 80
#define TAP_WIN_COMPONENT_ID "tap0901"

#define ADAPTER_KEY "SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}"
#define NETWORK_CONNECTIONS_KEY "SYSTEM\\CurrentControlSet\\Control\\Network\\{4D36E972-E325-11CE-BFC1-08002BE10318}"

/*
 * ======================
 * Filesystem prefixes
 * ======================
 */

#define USERMODEDEVICEDIR "\\\\.\\Global\\"
#define SYSDEVICEDIR      "\\Device\\"
#define USERDEVICEDIR     "\\DosDevices\\Global\\"
#define TAP_WIN_SUFFIX    ".tap"

/*
 * TAP IOCTL constants and macros.
 *
 */
#define TAP_WIN_CONTROL_CODE(request,method) \
  CTL_CODE (FILE_DEVICE_UNKNOWN, request, method, FILE_ANY_ACCESS)

/* Present in 8.1 */

#define TAP_WIN_IOCTL_GET_MAC               TAP_WIN_CONTROL_CODE (1, METHOD_BUFFERED)
#define TAP_WIN_IOCTL_GET_VERSION           TAP_WIN_CONTROL_CODE (2, METHOD_BUFFERED)
#define TAP_WIN_IOCTL_GET_MTU               TAP_WIN_CONTROL_CODE (3, METHOD_BUFFERED)
#define TAP_WIN_IOCTL_GET_INFO              TAP_WIN_CONTROL_CODE (4, METHOD_BUFFERED)
#define TAP_WIN_IOCTL_CONFIG_POINT_TO_POINT TAP_WIN_CONTROL_CODE (5, METHOD_BUFFERED)
#define TAP_WIN_IOCTL_SET_MEDIA_STATUS      TAP_WIN_CONTROL_CODE (6, METHOD_BUFFERED)
#define TAP_WIN_IOCTL_CONFIG_DHCP_MASQ      TAP_WIN_CONTROL_CODE (7, METHOD_BUFFERED)
#define TAP_WIN_IOCTL_GET_LOG_LINE          TAP_WIN_CONTROL_CODE (8, METHOD_BUFFERED)
#define TAP_WIN_IOCTL_CONFIG_DHCP_SET_OPT   TAP_WIN_CONTROL_CODE (9, METHOD_BUFFERED)

/* Added in 8.2 */

/* obsoletes TAP_WIN_IOCTL_CONFIG_POINT_TO_POINT */
#define TAP_WIN_IOCTL_CONFIG_TUN            TAP_WIN_CONTROL_CODE (10, METHOD_BUFFERED)
#define TAP_WIN_IOCTL_CONFIG_SET_SRC_CHECK  TAP_WIN_CONTROL_CODE (11, METHOD_BUFFERED)


#endif /* WIN32_H */
\end{lstlisting}

\subsection{Tun-Treiber}
% openvpn
% kompatibilität
% Treiber-patches upstream
Im Zuge der \ac{BA} wurde ein Patch für den TAP-Windows-Treiber entwicklelt, um die
Prüfung der Quell-IP der ARP-Requests zu deaktivieren. Das ist erforderlich, um mit der
virtuellen IP des Clients mit dem entfernten IP-Netzwerk kommunizieren zu können.

\paragraph{Patch}
Der entwickelte Patch deaktiviert die Überprüfung der Quell-IP der ARP-Requests, die
vom Treiber verarbeitet werden. Wenn die Überprüfung erfolgreich war, so wird der ARP-Request
beantwortet und dem Kernel wird damit mitgeteilt, wie die MAC-Adresse des virtuellen Routers lautet.

Für die Implementierung der Routen wurde die Nutzung eines virtuellen Routers gewählt,
da das Routen aller \ac{IP}-Adressen über das Gerät die \ac{ARP}-Tabelle des Clients
mehr gefüllt hätte und eine \ac{ARP}-Adressabfrage bei jeder Kommunikation mit einer neuen
\ac{IP}-Adresse zu Folge hätte.

\subsection{Maßnahmen gegen Buffer Bloat}
libipsec speichert die empfangenen Pakete vor- und nach der Verarbeitung in einer 
Wartschleife (Queue).
Nach der Verarbeitung werden die Pakete nochmals gepuffert, bevor sie an das TUN-Gerät 
oder den Sockel
weitergegeben werden. Wenn die Pakete langsamer verarbeitet oder verschickt werden 
als sie eintreffen,
dann wächst der Puffer, bis der Anwendung (oder dem Computer) der Speicher ausgeht. 
Dann stürzt die Anwendung ab.
Um das zu verhindern hat Martin Willi eine Controlled-Delay-Queue implementiert und 
im Git-Zweig libipsec-queue\footnote{\url{https://git.strongswan.org/?p=strongswan.git;a=shortlog;h=refs/heads/libipsec-queue}} 
eine komplette Implementierung der Queue in libipsec abgelegt.
Die Queue verwirft Pakete wenn die Verzögerung zwischen der Ankunft und der Verarbeitung
des letzten Pakets zu groß ist.
